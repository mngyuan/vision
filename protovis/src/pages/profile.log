SCRIPT  /Users/mngyuan/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim
Sourced 1 time
Total time:   0.009298
 Self time:   0.009298

count  total (s)   self (s)
    1              0.000032 if exists('*shiftwidth')
    1              0.000008   function! s:sw()
                                return shiftwidth()
                              endfunction
                            else
                              function! s:sw()
                                return &sw
                              endfunction
    1              0.000001 endif
                            
                            " Regexp for the start tag
    1              0.000006 let s:start_tag = '<\_s*\%(>\|\${\|\%(\<[-:._$A-Za-z0-9]\+\>\)\)'
                            " Regexp for the end tag
    1              0.000003 let s:end_tag = '\%(<\_s*/\_s*\%(\<[-:._$A-Za-z0-9]\+\>\)\_s*>\|/\_s*>\)'
                            
    1              0.000002 function s:trim(line)
                              return substitute(a:line, '^\s*\|\s*$', '', 'g')
                            endfunction
                            
                            " Get the syntax stack at the given position
    1              0.000002 function s:syntax_stack_at(lnum, col)
                              return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')
                            endfunction
                            
                            " Get the syntax at the given position
    1              0.000002 function s:syntax_at(lnum, col)
                              return synIDattr(synID(a:lnum, a:col, 1), 'name')
                            endfunction
                            
                            " Get the start col of the non-space charactor
    1              0.000002 function s:start_col(lnum)
                              return len(matchstr(getline(a:lnum), '^\s*')) + 1
                            endfunction
                            
                            " Get the start syntax of a given line number
    1              0.000002 function s:start_syntax(lnum)
                              return s:syntax_at(a:lnum, s:start_col(a:lnum))
                            endfunction
                            
                            " The skip function for searchpair
    1              0.000002 function s:skip_if_not(current_lnum, ...)
                              " Skip the match in current line
                              if line('.') == a:current_lnum
                                return 1
                              endif
                            
                              let syntax = s:syntax_at(line('.'), col('.'))
                              return syntax !~? join(a:000, '\|')
                            endfunction
                            
                            " Whether the specified stytax group is the opening tag
    1              0.000002 function s:is_opening_tag(syntax)
                              return a:syntax =~? 'jsxOpenPunct'
                            endfunction
                            
                            " Whether the specified stytax group is the closing tag
    1              0.000002 function s:is_closing_tag(syntax)
                              return a:syntax =~? 'jsxClose'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxRegion
    1              0.000002 function s:is_jsx_region(syntax)
                              return a:syntax =~? 'jsxRegion'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxElement
    1              0.000002 function s:is_jsx_element(syntax)
                              return a:syntax =~? 'jsxElement'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxExpressionBlock
    1              0.000002 function s:is_jsx_expression(syntax)
                              return a:syntax =~? 'jsxExpressionBlock'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxBraces
    1              0.000002 function s:is_jsx_brace(syntax)
                              return a:syntax =~? 'jsxBraces'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxComment
    1              0.000002 function s:is_jsx_comment(syntax)
                              return a:syntax =~? 'jsxComment'
                            endfunction
                            
                            " Whether the specified line is comment related syntax
    1              0.000002 function s:is_comment(syntax)
                              return a:syntax =~? 'comment'
                            endfunction
                            
                            " Whether the specified syntax group is the jsxComment
    1              0.000002 function s:is_jsx_backticks(syntax)
                              return a:syntax =~? 'jsxBackticks'
                            endfunction
                            
                            " Get the prvious line number
    1              0.000002 function s:prev_lnum(lnum)
                              return prevnonblank(a:lnum - 1)
                            endfunction
                            
                            " Whether the given pos is the parent of the given element who has
                            " element_count jsxElement syntax
    1              0.000002 function s:is_parent_element(pos, element_count)
                              let syntax_stack = s:syntax_stack_at(a:pos[0], a:pos[1])
                              return s:is_opening_tag(syntax_stack[-1]) &&
                                    \ count(syntax_stack, 'jsxElement') <= a:element_count
                            endfunction
                            
                            " Compute the indention of the trail punct
    1              0.000003 function s:jsx_indent_trail_punct(lnum)
                              let pair_line = searchpair('<', '', '>', 'bW', 's:skip_if_not(a:lnum, "jsxOpenPunct", "jsxClose")')
                              return indent(pair_line)
                            endfunction
                            
                            " Compute the indention of the closing tag
    1              0.000002 function s:jsx_indent_closing_tag(lnum)
                              let pair_line = searchpair(s:start_tag, '', s:end_tag, 'bW', 's:skip_if_not(a:lnum, "jsxOpenPunct", "jsxClose")')
                              return pair_line ? indent(pair_line) : indent(a:lnum)
                            endfunction
                            
                            " Compute the indentation of the jsxElement
    1              0.000002 function s:jsx_indent_element(lnum)
                              let syntax_stack = s:syntax_stack_at(a:lnum, s:start_col(a:lnum))
                              let syntax_name = syntax_stack[-1]
                              let element_count = count(syntax_stack, 'jsxElement')
                            
                              if s:trim(getline(a:lnum)) =~ '^>'
                                return s:jsx_indent_trail_punct(a:lnum)
                              endif
                            
                              " If current tag is closing tag
                              if s:is_closing_tag(syntax_name)
                                return s:jsx_indent_closing_tag(a:lnum)
                              endif
                            
                              " Normalize the jsxElement count for opening tag
                              if s:is_opening_tag(syntax_name)
                                " <div>
                                "   <div></div> <-- jsxRegion->jsxElement->jsxElement->jsxTag->jsxOpenTag->jsxOpenPunct
                                " </div>
                                if s:is_jsx_element(syntax_stack[-4]) && s:is_jsx_element(syntax_stack[-5])
                                  let element_count = element_count - 1
                                endif
                              endif
                            
                              let start_time = localtime()
                              let pos = searchpos(s:start_tag, 'bW')
                            
                              while !s:is_parent_element(pos, element_count)
                                if localtime() - start_time >= 0.5
                                  return -1
                                endif
                                let pos = searchpos(s:start_tag, 'bW')
                              endwhile
                            
                              return indent(pos[0]) + s:sw()
                            endfunction
                            
                            " Compute the indentation of the comment
    1              0.000002 function s:jsx_indent_comment(lnum)
                              let line = s:trim(getline(a:lnum))
                            
                              if s:is_jsx_comment(s:start_syntax(a:lnum))
                                if line =~ '^<!--' || line =~ '^-->'
                                  return s:jsx_indent_element(a:lnum)
                                else
                                  return s:jsx_indent_element(a:lnum) + s:sw()
                                endif
                              else
                                if line =~ '^/\*' || line =~ '^//'
                                  return s:jsx_indent_element(a:lnum)
                                else
                                  return s:jsx_indent_element(a:lnum) + 1
                                endif
                              endif
                            endfunction
                            
                            " Compute the indentation of jsxBackticks
    1              0.000002 function s:jsx_indent_backticks(lnum)
                              let tags = get(g:, 'vim_jsx_pretty_template_tags', ['html', 'jsx'])
                              let start_tag = '\%(' . join(tags, '\|') . '\)`'
                              let end_tag = '\%(' . join(tags, '\|') . '\)\@<!`'
                              let pair_line = searchpair(start_tag, '', end_tag, 'bW', 's:skip_if_not(a:lnum)')
                            
                              return indent(pair_line)
                            endfunction
                            
                            " Syntax context types:
                            " - jsxRegion
                            " - jsxTaggedRegion
                            " - jsxElement
                            " - jsxExpressionBlock
                            " - Other
    1              0.000002 function s:syntax_context(lnum)
                              let start_col = s:start_col(a:lnum)
                              let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
                              let start_syntax = syntax_stack[-1]
                              let reversed = reverse(syntax_stack)
                              let i = 0
                            
                              for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
                                if s:is_jsx_expression(syntax_name)
                                  return 'jsxExpressionBlock'
                                endif
                            
                                if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
                                endif
                            
                                if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
                                endif
                            
                                let i = i + 1
                              endfor
                              
                              return 'Other'
                            endfunction
                            
                            
    1              0.000002 function! jsx_pretty#indent#get(js_indent)
                              let line = s:trim(getline(v:lnum))
                              let start_syntax = s:start_syntax(v:lnum)
                            
                              if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
                              endif
                            
                              if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
                              endif
                            
                              if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
                              endif
                            
                              let syntax_context = s:syntax_context(v:lnum)
                            
                              if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' &&
                                      \ s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
                              elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
                              elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
                              elseif syntax_context == 'jsxExpressionBlock'
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
                                elseif line =~ '^:'
                                  return indent(prev_lnum)
                                else
                                  return a:js_indent()
                                endif
                              endif
                            
                              return a:js_indent()
                            endfunction

FUNCTION  coc#client#get_channel()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 141
Called 92 times
Total time:   0.000749
 Self time:   0.000749

count  total (s)   self (s)
   92              0.000160   if s:is_vim
                                return a:client['channel']
   92              0.000065   endif
   92              0.000223   return a:client['chan_id']

FUNCTION  <SNR>94_GetPair()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 71
Called 1 time
Total time:   0.001207
 Self time:   0.000613

count  total (s)   self (s)
    1   0.001206   0.000613     return searchpair('\m'.a:start,'','\m'.a:end,a:flags,a:skip,s:l1,a:skip ==# 's:SkipFunc()' ? 2000 : 200)

FUNCTION  coc#highlight#clear_match_group()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim line 211
Called 2 times
Total time:   0.000792
 Self time:   0.000792

count  total (s)   self (s)
    2              0.000009   let winid = a:winid == 0 ? win_getid() : a:winid
    2              0.000020   if empty(getwininfo(winid))
                                " not valid
                                return
    2              0.000001   endif
    2              0.000003   if s:clear_match_by_window
                                let arr = filter(getmatches(winid), 'v:val["group"] =~# "'.a:match.'"')
                                for item in arr
                                  call matchdelete(item['id'], winid)
                                endfor
    2              0.000001   else
    2              0.000004     let curr = win_getid()
    2              0.000009     let switch = exists('*nvim_set_current_win') && curr != winid
    2              0.000002     if switch
                                  noa call nvim_set_current_win(a:winid)
    2              0.000001     endif
    2              0.000003     if win_getid() == winid
    2              0.000663       let arr = filter(getmatches(), 'v:val["group"] =~# "'.a:match.'"')
    7              0.000007       for item in arr
    5              0.000012         call matchdelete(item['id'])
    7              0.000004       endfor
    2              0.000001     endif
    2              0.000002     if switch
                                  noa call nvim_set_current_win(curr)
    2              0.000001     endif
    2              0.000001   endif

FUNCTION  airline#util#exec_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 93
Called 3 times
Total time:   0.004757
 Self time:   0.000518

count  total (s)   self (s)
   30              0.000037     for Fn in a:list
   30   0.004623   0.000384       let code = call(Fn, a:000)
   30              0.000031       if code != 0
    3              0.000003         return code
   27              0.000013       endif
   27              0.000014     endfor
                                return 0

FUNCTION  <SNR>186_reset_summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 24
Called 8 times
Total time:   0.000234
 Self time:   0.000098

count  total (s)   self (s)
    8   0.000231   0.000094   call gitgutter#utility#setbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>51_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 164
Called 132 times
Total time:   0.002470
 Self time:   0.002470

count  total (s)   self (s)
  132              0.000255   let dir = a:path
  132              0.001499   if dir =~# '/\.git$'
  132              0.000578     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
                                return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>154_is_excluded_window()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim line 111
Called 3 times
Total time:   0.000157
 Self time:   0.000157

count  total (s)   self (s)
    3              0.000012   for matchft in g:airline_exclude_filetypes
                                if matchft ==# &ft
                                  return 1
                                endif
    3              0.000003   endfor
                            
   12              0.000018   for matchw in g:airline_exclude_filenames
    9              0.000067     if matchstr(expand('%'), matchw) ==# matchw
                                  return 1
    9              0.000004     endif
   12              0.000007   endfor
                            
    3              0.000005   if g:airline_exclude_preview && &previewwindow
                                return 1
    3              0.000001   endif
                            
    3              0.000002   return 0

FUNCTION  <SNR>23_abs_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 205
Called 46 times
Total time:   0.007846
 Self time:   0.007846

count  total (s)   self (s)
   46              0.005381   let p = resolve(expand('#'.a:bufnr.':p'))
                            
                              " Remove extra parts from fugitive's filepaths
   46              0.001894   let p = substitute(substitute(p, '^fugitive:', '', ''), '\v\.git/\x{40,}/', '', '')
                            
   46              0.000350   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  airline#extensions#coc#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 14
Called 132 times
Total time:   0.007470
 Self time:   0.001619

count  total (s)   self (s)
  132   0.007408   0.001558   return airline#extensions#coc#get('error')

FUNCTION  airline#statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 190
Called 132 times
Total time:   0.002373
 Self time:   0.002373

count  total (s)   self (s)
  132              0.000982   if has_key(s:contexts, a:winnr)
  132              0.001174     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  <SNR>23_is_file_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 63
Called 11 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   11              0.000180   return empty(getbufvar(a:bufnr, '&buftype'))

FUNCTION  <SNR>195_syntax_context()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 194
Called 1 time
Total time:   0.126235
 Self time:   0.000527

count  total (s)   self (s)
    1   0.000024   0.000009   let start_col = s:start_col(a:lnum)
    1   0.125572   0.000016   let syntax_stack = s:syntax_stack_at(a:lnum, start_col)
    1              0.000009   let start_syntax = syntax_stack[-1]
    1              0.000004   let reversed = reverse(syntax_stack)
    1              0.000001   let i = 0
                            
   10              0.000014   for syntax_name in reversed
                                " If the current line is jsxExpressionBlock and not starts with jsxBraces
   10   0.000180   0.000115     if s:is_jsx_expression(syntax_name)
    1              0.000002       return 'jsxExpressionBlock'
    9              0.000006     endif
                            
    9   0.000125   0.000089     if s:is_jsx_region(syntax_name)
                                  return 'jsxRegion'
    9              0.000005     endif
                            
    9   0.000113   0.000078     if s:is_jsx_element(syntax_name)
                                  " If current line starts with the opening tag
                                  if s:is_opening_tag(start_syntax) || s:is_closing_tag(start_syntax)
                                    " And the next syntax is jsxRegion
                                    if s:is_jsx_region(reversed[i+1])
                                      return 'jsxRegion'
                                    elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                      return 'jsxTaggedRegion'
                                    else
                                      return 'jsxElement'
                                    endif
                                  elseif reversed[i+1] =~ 'jsxTaggedRegion'
                                    return 'jsxTaggedRegion'
                                  else
                                    return 'jsxElement'
                                  endif
    9              0.000004     endif
                            
    9              0.000012     let i = i + 1
    9              0.000005   endfor
                              
                              return 'Other'

FUNCTION  GetJsxIndent()
    Defined: ~/.vim/plugged/vim-jsx-pretty/after/indent/jsx.vim line 24
Called 1 time
Total time:   4.815756
 Self time:   0.000570

count  total (s)   self (s)
    1   4.815755   0.000569   return jsx_pretty#indent#get(function('GetJavascriptIndent'))

FUNCTION  <SNR>195_is_jsx_region()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 62
Called 9 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    9              0.000033   return a:syntax =~? 'jsxRegion'

FUNCTION  airline#util#append()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 49
Called 924 times
Total time:   0.011738
 Self time:   0.011738

count  total (s)   self (s)
  924              0.002628   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  924              0.000497   endif
  924              0.003611   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  924              0.003182   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>195_is_opening_tag()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 52
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   return a:syntax =~? 'jsxOpenPunct'

FUNCTION  <SNR>190_process_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 319
Called 8 times
Total time:   0.003383
 Self time:   0.003383

count  total (s)   self (s)
    8              0.000013   let offset = 0
   56              0.000086   while offset < a:from_count
   48              0.000101     let line_number = a:to_line + offset
   48              0.000161     call add(a:modifications, [line_number, 'modified'])
   48              0.000071     let offset += 1
   56              0.000040   endwhile
  336              0.000433   while offset < a:to_count
  328              0.000611     let line_number = a:to_line + offset
  328              0.000990     call add(a:modifications, [line_number, 'added'])
  328              0.000443     let offset += 1
  336              0.000197   endwhile

FUNCTION  <SNR>161_CheckDefined()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 126
Called 569 times
Total time:   0.014277
 Self time:   0.014277

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  569              0.002169   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
  569              0.000293   endif
  569              0.001976   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
  569              0.000276   endif
                            
  569              0.001203   for val in a:colors
  569              0.001715     if !empty(val) && val !=# 'NONE'
  569              0.000651       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#util#try_focusgained()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 203
Called 3 times
Total time:   0.000039
 Self time:   0.000039

count  total (s)   self (s)
                              " Ignore lasts for at most one second and is cleared on the first
                              " focusgained. We use ignore to prevent system() calls from triggering
                              " FocusGained (which occurs 100% on win32 and seem to sometimes occur under
                              " tmux).
    3              0.000013   let dt = localtime() - s:focusgained_ignore_time
    3              0.000011   let s:focusgained_ignore_time = 0
    3              0.000004   return dt >= 1

FUNCTION  airline#extensions#branch#update_untracked_config()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 183
Called 132 times
Total time:   0.002225
 Self time:   0.002225

count  total (s)   self (s)
  132              0.000632   if !has_key(s:vcs_config[a:vcs].untracked, a:file)
                                return
  132              0.000767   elseif s:vcs_config[a:vcs].untracked[a:file] != b:buffer_vcs_config[a:vcs].untracked
                                let b:buffer_vcs_config[a:vcs].untracked = s:vcs_config[a:vcs].untracked[a:file]
                                unlet! b:airline_head
  132              0.000078   endif

FUNCTION  airline#themes#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/themes.vim line 31
Called 336 times
Total time:   0.062195
 Self time:   0.005286

count  total (s)   self (s)
  336   0.062060   0.005151   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  airline#mode_changed()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 279
Called 23 times
Total time:   0.000766
 Self time:   0.000597

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
   23              0.000262   let g:airline#visual_active = (mode() =~? '[vs]')
   23   0.000445   0.000276   call airline#update_tabline()

FUNCTION  FugitiveWorkTree()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 151
Called 132 times
Total time:   0.011637
 Self time:   0.002397

count  total (s)   self (s)
  132   0.011567   0.002326   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>58_TmuxBufferName()
    Defined: ~/.vim/plugged/vim-tmux-clipboard/plugin/vimtmuxclipboard.vim line 2
Called 12 times
Total time:   2.587694
 Self time:   0.001388

count  total (s)   self (s)
   12   2.587278   0.000972     let l:list = systemlist('tmux list-buffers -F"#{buffer_name}"')
   12              0.000235     if len(l:list)==0
                                    return ""
   12              0.000019     else
   12              0.000053         return l:list[0]
                                endif

FUNCTION  <SNR>58_update_from_tmux()
    Defined: ~/.vim/plugged/vim-tmux-clipboard/plugin/vimtmuxclipboard.vim line 47
Called 6 times
Total time:   2.588294
 Self time:   0.000600

count  total (s)   self (s)
    6   1.397784   0.000227     let buffer_name = s:TmuxBufferName()
    6              0.000022     if s:lastbname != buffer_name
                                    let @" = s:TmuxBuffer()
    6              0.000004     endif
    6   1.190433   0.000296     let s:lastbname=s:TmuxBufferName()

FUNCTION  <SNR>23_winshell()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 68
Called 8 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
    8              0.000167   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  airline#extensions#coc#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 10
Called 132 times
Total time:   0.008010
 Self time:   0.001618

count  total (s)   self (s)
  132   0.007944   0.001552   return airline#extensions#coc#get('warning')

FUNCTION  airline#extensions#coc#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 45
Called 132 times
Total time:   0.006395
 Self time:   0.001803

count  total (s)   self (s)
                              " Shorten text for windows < 91 characters
  132   0.006244   0.001652   return airline#util#shorten(get(g:, 'coc_status', ''), 91, 9)

FUNCTION  <SNR>188_on_exit_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 72
Called 8 times
Total time:   0.055783
 Self time:   0.000496

count  total (s)   self (s)
    8              0.000021   if !a:exit_code
    8   0.055748   0.000462     call self.handler.out(self.buffer, join(self.stdoutbuffer, "\n"))
    8              0.000005   endif

FUNCTION  <SNR>164_get_hunks_gitgutter()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 60
Called 132 times
Total time:   0.010244
 Self time:   0.003424

count  total (s)   self (s)
  132   0.002927   0.001787   if !get(g:, 'gitgutter_enabled', 0) || s:is_branch_empty()
    3              0.000002     return ''
  129              0.000070   endif
  129   0.007005   0.001326   return GitGutterGetHunkSummary()

FUNCTION  <SNR>188_build_command()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 43
Called 8 times
Total time:   0.000095
 Self time:   0.000095

count  total (s)   self (s)
    8              0.000037   if has('unix')
    8              0.000032     return ['sh', '-c', a:cmd]
                              endif
                            
                              if has('win32')
                                return has('nvim') ? ['cmd.exe', '/c', a:cmd] : 'cmd.exe /c '.a:cmd
                              endif
                            
                              throw 'unknown os'

FUNCTION  airline#highlighter#highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 237
Called 23 times
Total time:   0.267966
 Self time:   0.044994

count  total (s)   self (s)
   23              0.000060   let bufnr = a:0 ? a:1 : ''
   23              0.000090   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
   23              0.000275   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
   23              0.000074   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
   23              0.000048   let airline_grouplist = []
   23              0.000118   let buffers_in_tabpage = sort(tabpagebuflist())
   23              0.000063   if exists("*uniq")
   23              0.000078     let buffers_in_tabpage = uniq(buffers_in_tabpage)
   23              0.000014   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
   58              0.000362   for mode in reverse(mapped)
   35              0.000248     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
   21              0.000092       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
  315              0.000656       for kvp in items(dict)
  294              0.000562         let mode_colors = kvp[1]
  294              0.000525         let name = kvp[0]
  294              0.000884         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
  294              0.000168         endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
  294              0.002008         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
  294              0.001546         elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
  140              0.000105           continue
  154              0.000087         endif
  154   0.003074   0.001789         if s:group_not_done(airline_grouplist, name.suffix)
  126   0.045253   0.003317           call airline#highlighter#exec(name.suffix, mode_colors)
  154              0.000095         endif
                            
  154              0.000383         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
  154              0.000089         endif
                            
  462              0.000858         for accent in keys(s:accents)
  308              0.000792           if !has_key(p.accents, accent)
                                        continue
  308              0.000204           endif
  308              0.001272           let colors = copy(mode_colors)
  308              0.000758           if p.accents[accent][0] != ''
  154              0.000431             let colors[0] = p.accents[accent][0]
  308              0.000169           endif
  308              0.000688           if p.accents[accent][2] != ''
  154              0.000402             let colors[2] = p.accents[accent][2]
  308              0.000163           endif
  308              0.000556           if len(colors) >= 5
  308              0.001137             let colors[4] = get(p.accents[accent], 4, '')
                                      else
                                        call add(colors, get(p.accents[accent], 4, ''))
  308              0.000159           endif
  308   0.006142   0.003694           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
  252   0.078306   0.003451             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
  308              0.000183           endif
  462              0.000292         endfor
  175              0.000118       endfor
                            
   21              0.000039       if empty(s:separators)
                                    " nothing to be done
                                    continue
   21              0.000011       endif
                                  " TODO: optimize this
  168              0.000341       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
  147   0.104536   0.002088         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
  168              0.000133       endfor
   35              0.000020     endif
   58              0.000149   endfor

FUNCTION  coc#float#check_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim line 798
Called 8 times
Total time:   0.001070
 Self time:   0.001070

count  total (s)   self (s)
    8              0.000045   let invalids = []
    8              0.000027   if s:is_vim
                                if !exists('*popup_list')
                                  return
                                endif
                                for id in popup_list()
                                  let target = getwinvar(id, 'target_winid', 0)
                                  if (target && !s:popup_visible(target)) || getwinvar(id, 'kind', '') == 'pum'
                                    call add(invalids, id)
                                  endif
                                endfor
    8              0.000011   else
   16              0.000104     for i in range(1, winnr('$'))
    8              0.000069       let target = getwinvar(i, 'target_winid', 0)
    8              0.000037       if target && !nvim_win_is_valid(target)
                                    call add(invalids, win_getid(i))
    8              0.000051       elseif getwinvar(i, 'kind', '') == 'pum'
                                    call add(invalids, win_getid(i))
    8              0.000009       endif
   16              0.000030     endfor
    8              0.000010   endif
    8              0.000026   for id in invalids
                                call coc#float#close(id)
    8              0.000014   endfor

FUNCTION  airline#util#has_fugitive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 143
Called 264 times
Total time:   0.002221
 Self time:   0.002221

count  total (s)   self (s)
  264              0.000799   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
  264              0.000149   endif
  264              0.000336   return s:has_fugitive

FUNCTION  <SNR>156_invoke_funcrefs()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 177
Called 3 times
Total time:   0.032399
 Self time:   0.000208

count  total (s)   self (s)
    3   0.000138   0.000043   let builder = airline#builder#new(a:context)
    3   0.004810   0.000053   let err = airline#util#exec_funcrefs(a:funcrefs + s:core_funcrefs, builder, a:context)
    3              0.000003   if err == 1
    3   0.027362   0.000022     let a:context.line = builder.build()
    3              0.000023     let s:contexts[a:context.winnr] = a:context
    3              0.000012     let option = get(g:, 'airline_statusline_ontop', 0) ? '&tabline' : '&statusline'
    3              0.000045     call setwinvar(a:context.winnr, option, '%!airline#statusline('.a:context.winnr.')')
    3              0.000002   endif

FUNCTION  jsx_pretty#indent#get()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 236
Called 1 time
Total time:   4.805732
 Self time:   0.000224

count  total (s)   self (s)
    1   0.000044   0.000016   let line = s:trim(getline(v:lnum))
    1   0.137617   0.000015   let start_syntax = s:start_syntax(v:lnum)
                            
    1   0.000040   0.000027   if s:is_jsx_backticks(start_syntax)
                                return s:jsx_indent_backticks(v:lnum)
    1              0.000001   endif
                            
    1   0.000029   0.000023   if s:is_jsx_brace(start_syntax)
                                return s:jsx_indent_element(v:lnum)
    1              0.000001   endif
                            
    1   0.000015   0.000010   if s:is_opening_tag(start_syntax) && line =~ '^>'
                                return s:jsx_indent_trail_punct(v:lnum)
    1              0.000001   endif
                            
    1   0.126251   0.000016   let syntax_context = s:syntax_context(v:lnum)
                            
    1              0.000003   if syntax_context == 'jsxRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                endif
                            
                                let prev_lnum = s:prev_lnum(v:lnum)
                                let prev_line = s:trim(getline(prev_lnum))
                            
                                if prev_line =~ '[([{=?]$'
                                  return indent(prev_lnum) + s:sw()
                                elseif prev_line =~ '[:|&<>]$' && s:trim(getline(s:prev_lnum(prev_lnum))) !~ '[?:|&<>]$'
                                  return indent(prev_lnum) + s:sw()
                                else
                                  return indent(prev_lnum)
                                endif
    1              0.000002   elseif syntax_context == 'jsxTaggedRegion'
                                if s:is_closing_tag(start_syntax)
                                  return s:jsx_indent_closing_tag(v:lnum)
                                elseif s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                else
                                  return indent(s:prev_lnum(v:lnum)) + s:sw()
                                endif
    1              0.000002   elseif syntax_context == 'jsxElement'
                                if s:is_jsx_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                if s:is_comment(start_syntax)
                                  return s:jsx_indent_comment(v:lnum)
                                endif
                            
                                return s:jsx_indent_element(v:lnum)
    1              0.000002   elseif syntax_context == 'jsxExpressionBlock'
    1   0.000016   0.000010     let prev_lnum = s:prev_lnum(v:lnum)
    1   0.000030   0.000010     let prev_line = s:trim(getline(prev_lnum))
                            
    1              0.000003     if line =~ '^?'
                                  return indent(prev_lnum) + s:sw()
    1              0.000003     elseif line =~ '^:'
                                  return indent(prev_lnum)
    1              0.000001     else
    1   4.541607   0.000014       return a:js_indent()
                                endif
                              endif
                            
                              return a:js_indent()

FUNCTION  gitgutter#utility#get_diff_base()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 196
Called 8 times
Total time:   0.001351
 Self time:   0.001351

count  total (s)   self (s)
    8              0.000875   let p = resolve(expand('#'.a:bufnr.':p'))
    8              0.000304   let ml = matchlist(p, '\v^fugitive:/.*/(\x{40,})/')
    8              0.000069   if !empty(ml) && !empty(ml[1])
                                return ml[1].'^'
    8              0.000011   endif
    8              0.000035   return g:gitgutter_diff_base

FUNCTION  <SNR>23_unc_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 169
Called 8 times
Total time:   0.001483
 Self time:   0.000242

count  total (s)   self (s)
    8   0.001473   0.000232   return s:abs_path(a:bufnr, 0) =~ '^\\\\'

FUNCTION  <SNR>23_exists_file()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 223
Called 11 times
Total time:   0.003609
 Self time:   0.000605

count  total (s)   self (s)
   11   0.003594   0.000591   return filereadable(s:abs_path(a:bufnr, 0))

FUNCTION  airline#parts#filetype()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 102
Called 132 times
Total time:   0.003213
 Self time:   0.001847

count  total (s)   self (s)
  132   0.003137   0.001771   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? '…' : '>') : &filetype

FUNCTION  airline#extensions#netrw#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/netrw.vim line 11
Called 3 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    3              0.000013   if &ft == 'netrw'
                                let spc = g:airline_symbols.space
                            
                                call a:1.add_section('airline_a', spc.'netrw'.spc)
                                if exists('*airline#extensions#branch#get_head')
                                  call a:1.add_section('airline_b', spc.'%{airline#extensions#branch#get_head()}'.spc)
                                endif
                                call a:1.add_section('airline_c', spc.'%f'.spc)
                                call a:1.split()
                                call a:1.add_section('airline_y', spc.'%{airline#extensions#netrw#sortstring()}'.spc)
                                return 1
    3              0.000001   endif

FUNCTION  airline#parts#iminsert()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 82
Called 132 times
Total time:   0.000988
 Self time:   0.000988

count  total (s)   self (s)
  132              0.000413   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
  132              0.000075   endif
  132              0.000106   return ''

FUNCTION  airline#update_tabline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 273
Called 81 times
Total time:   0.000607
 Self time:   0.000607

count  total (s)   self (s)
   81              0.000296   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
   81              0.000046   endif

FUNCTION  airline#extensions#term#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/term.vim line 14
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000020   if &buftype ==? 'terminal' || bufname(a:2.bufnr)[0] ==? '!'
                                call a:1.add_section_spaced('airline_a', s:section_a)
                                call a:1.add_section_spaced('airline_b', s:neoterm_id(a:2.bufnr))
                                call a:1.add_section('airline_term', s:spc.s:termname(a:2.bufnr))
                                call a:1.split()
                                call a:1.add_section('airline_y', '')
                                call a:1.add_section_spaced('airline_z', s:section_z)
                                return 1
    3              0.000001   endif

FUNCTION  airline#highlighter#exec()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 102
Called 569 times
Total time:   0.171107
 Self time:   0.041463

count  total (s)   self (s)
  569              0.000909   if pumvisible()
                                return
  569              0.000266   endif
  569              0.000955   let colors = a:colors
  569              0.000636   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
  569              0.000285   endif
  569   0.111021   0.008003   let old_hi = airline#highlighter#get_highlight(a:group)
  569              0.001101   if len(colors) == 4
  171              0.000382     call add(colors, '')
  569              0.000288   endif
  569              0.004457   let new_hi = [colors[0], colors[1], printf('%s', colors[2]), printf('%s', colors[3]), colors[4]]
  569   0.020007   0.005730   let colors = s:CheckDefined(colors)
  569   0.011354   0.006045   if old_hi != new_hi || !s:hl_group_exists(a:group)
   67   0.007788   0.000749     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   67              0.000525     exe cmd
   67              0.000174     if has_key(s:hl_groups, a:group)
   67              0.000166       let s:hl_groups[a:group] = colors
   67              0.000037     endif
  569              0.000260   endif

FUNCTION  <SNR>94_LookingAt()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 161
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000020   return getline('.')[col('.')-1]

FUNCTION  coc#float#get_related()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim line 1209
Called 55 times
Total time:   0.000732
 Self time:   0.000732

count  total (s)   self (s)
   55              0.000296   for winid in getwinvar(a:winid, 'related', [])
                                if getwinvar(winid, 'kind', '') ==# a:kind
                                  return winid
                                endif
   55              0.000066   endfor
   55              0.000053   return 0

FUNCTION  gitgutter#process_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 21
Called 11 times
Total time:   0.109544
 Self time:   0.002668

count  total (s)   self (s)
                              " NOTE a:bufnr is not necessarily the current buffer.
                            
   11   0.009553   0.000317   if gitgutter#utility#is_active(a:bufnr)
                            
   11              0.000117     if has('patch-7.4.1559')
   11              0.000190       let l:Callback = function('gitgutter#process_buffer', [a:bufnr, a:force])
                                else
                                  let l:Callback = {'function': 'gitgutter#process_buffer', 'arguments': [a:bufnr, a:force]}
   11              0.000015     endif
   11   0.001596   0.000316     let how = s:setup_path(a:bufnr, l:Callback)
   11              0.000070     if [how] == ['async']  " avoid string-to-number conversion if how is a number
                                  return
   11              0.000013     endif
                            
   11   0.000781   0.000297     if a:force || s:has_fresh_changes(a:bufnr)
                            
    8              0.000091       let diff = 'NOT SET'
    8              0.000015       try
    8   0.096248   0.000372         let diff = gitgutter#diff#run_diff(a:bufnr, g:gitgutter_diff_relative_to, 0)
                                  catch /gitgutter not tracked/
                                    call gitgutter#debug#log('Not tracked: '.gitgutter#utility#file(a:bufnr))
                                  catch /gitgutter diff failed/
                                    call gitgutter#debug#log('Diff failed: '.gitgutter#utility#file(a:bufnr))
                                    call gitgutter#hunk#reset(a:bufnr)
    8              0.000021       endtry
                            
    8              0.000065       if diff != 'async' && diff != 'NOT SET'
                                    call gitgutter#diff#handler(a:bufnr, diff)
    8              0.000010       endif
                            
   11              0.000022     endif
   11              0.000011   endif

FUNCTION  airline#extensions#coc#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/coc.vim line 18
Called 264 times
Total time:   0.012243
 Self time:   0.012243

count  total (s)   self (s)
  264              0.000869   if !exists(':CocCommand')
                                return ''
  264              0.000141   endif
  264              0.001017   let _backup = get(g:, 'coc_stl_format', '')
  264              0.000716   let is_err = (a:type  is# 'error')
  264              0.000274   if is_err
  132              0.000884     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_err', '%E{[%e(#%fe)]}')
  132              0.000077   else
  132              0.000952     let g:coc_stl_format = get(g:, 'airline#extensions#coc#stl_format_warn', '%W{[%w(#%fw)]}')
  264              0.000154   endif
  264              0.001036   let info = get(b:, 'coc_diagnostic_info', {})
  264              0.000821   if empty(info) | return '' | endif
                            
                            
  264              0.000838   let cnt = get(info, a:type, 0)
  264              0.000538   if !empty(_backup)
  264              0.000958     let g:coc_stl_format = _backup
  264              0.000152   endif
                            
  264              0.000450   if empty(cnt)
  264              0.000228     return ''
                              else
                                return (is_err ? s:error_symbol : s:warning_symbol).cnt
                              endif

FUNCTION  gitgutter#diff#parse_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 205
Called 8 times
Total time:   0.005503
 Self time:   0.002103

count  total (s)   self (s)
    8              0.000016   let hunks = []
  104              0.000196   for line in split(a:diff, '\n')
   96   0.004643   0.001244     let hunk_info = gitgutter#diff#parse_hunk(line)
   96              0.000182     if len(hunk_info) == 4
   96              0.000227       call add(hunks, hunk_info)
   96              0.000054     endif
  104              0.000064   endfor
    8              0.000009   return hunks

FUNCTION  gitgutter#utility#has_repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 102
Called 11 times
Total time:   0.001003
 Self time:   0.000364

count  total (s)   self (s)
   11   0.000992   0.000353   return index(['', -1, -2], gitgutter#utility#repo_path(a:bufnr, 0)) == -1

FUNCTION  <SNR>195_is_jsx_expression()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 72
Called 10 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   10              0.000061   return a:syntax =~? 'jsxExpressionBlock'

FUNCTION  <SNR>17_on_cursor_moved()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 83
Called 55 times
Total time:   0.001635
 Self time:   0.001221

count  total (s)   self (s)
   55              0.000394   if winnr() != s:active_winnr || !exists('w:airline_active')
                                call s:on_window_changed('CursorMoved')
   55              0.000040   endif
   55   0.000982   0.000568   call airline#update_tabline()

FUNCTION  <SNR>165_format_name()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 77
Called 3 times
Total time:   0.000007
 Self time:   0.000007

count  total (s)   self (s)
    3              0.000003     return a:name

FUNCTION  airline#extensions#po#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/po.vim line 54
Called 3 times
Total time:   0.000023
 Self time:   0.000023

count  total (s)   self (s)
    3              0.000008   if &ft ==# 'po'
                                call airline#extensions#prepend_to_section('z', '%{airline#extensions#po#stats()}')
                                " Also reset the cache variable, if a window has been split, e.g. the winwidth changed
                                autocmd airline BufWritePost * unlet! b:airline_po_stats
                                autocmd airline WinEnter * call airline#extensions#po#on_winenter()
    3              0.000001   endif

FUNCTION  gitgutter#utility#cd_cmd()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 164
Called 8 times
Total time:   0.004015
 Self time:   0.000675

count  total (s)   self (s)
    8   0.002125   0.000496   let cd = s:unc_path(a:bufnr) ? 'pushd' : (gitgutter#utility#windows() && s:dos_shell() ? 'cd /d' : 'cd')
    8   0.001875   0.000163   return cd.' '.s:dir(a:bufnr).' && '.a:cmd

FUNCTION  airline#util#winwidth()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 19
Called 1589 times
Total time:   0.018330
 Self time:   0.018330

count  total (s)   self (s)
 1589              0.004846   let nr = get(a:000, 0, 0)
 1589              0.005284   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
 1589              0.001527   else
 1589              0.003120     return winwidth(nr)
                              endif

FUNCTION  <SNR>94_SynAt()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 80
Called 41 times
Total time:   4.418236
 Self time:   4.418236

count  total (s)   self (s)
   41              0.000191   let byte = line2byte(a:l) + a:c - 1
   41              0.000165   let pos = index(s:synid_cache[0], byte)
   41              0.000065   if pos == -1
   39              4.417415     let s:synid_cache[:] += [[byte], [synIDattr(synID(a:l, a:c, 0), 'name')]]
   41              0.000125   endif
   41              0.000187   return s:synid_cache[1][pos]

FUNCTION  <SNR>176_get_accented_line()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 163
Called 24 times
Total time:   0.001359
 Self time:   0.001359

count  total (s)   self (s)
   24              0.000031   if a:self._context.active
                                " active window
   24              0.000034     let contents = []
   24              0.000158     let content_parts = split(a:contents, '__accent')
   66              0.000087     for cpart in content_parts
   42              0.000327       let accent = matchstr(cpart, '_\zs[^#]*\ze')
   42              0.000108       call add(contents, cpart)
   66              0.000048     endfor
   24              0.000095     let line = join(contents, a:group)
   24              0.000174     let line = substitute(line, '__restore__', a:group, 'g')
                              else
                                " inactive window
                                let line = substitute(a:contents, '%#__accent[^#]*#', '', 'g')
                                let line = substitute(line, '%#__restore__#', '', 'g')
   24              0.000012   endif
   24              0.000023   return line

FUNCTION  airline#util#doautocmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 176
Called 26 times
Total time:   0.003043
 Self time:   0.001196

count  total (s)   self (s)
   26   0.003023   0.001177   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  <SNR>190_is_modified_and_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 285
Called 16 times
Total time:   0.000058
 Self time:   0.000058

count  total (s)   self (s)
   16              0.000048   return a:from_count > 0 && a:to_count > 0 && a:from_count < a:to_count

FUNCTION  airline#extensions#commandt#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/commandt.vim line 11
Called 3 times
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    3              0.000008   if bufname('%') ==# 'GoToFile'
                                call airline#extensions#apply_left_override('CommandT', '')
    3              0.000002   endif

FUNCTION  <SNR>190_process_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 310
Called 64 times
Total time:   0.002175
 Self time:   0.002175

count  total (s)   self (s)
   64              0.000094   let offset = 0
  232              0.000341   while offset < a:to_count
  168              0.000354     let line_number = a:to_line + offset
  168              0.000566     call add(a:modifications, [line_number, 'modified'])
  168              0.000242     let offset += 1
  232              0.000171   endwhile

FUNCTION  300()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 62
Called 3 times
Total time:   0.027340
 Self time:   0.002710

count  total (s)   self (s)
    3              0.000004   let side = 1
    3              0.000003   let line = ''
    3              0.000003   let i = 0
    3              0.000007   let length = len(self._sections)
    3              0.000004   let split = 0
    3              0.000004   let is_empty = 0
    3              0.000004   let prev_group = ''
                            
   30              0.000039   while i < length
   27              0.000057     let section = self._sections[i]
   27              0.000048     let group = section[0]
   27              0.000048     let contents = section[1]
   27              0.000040     let pgroup = prev_group
   27   0.000596   0.000303     let prev_group = airline#builder#get_prev_group(self._sections, i)
   27              0.000068     if group ==# 'airline_c' && &buftype ==# 'terminal' && self._context.active
                                  let group = 'airline_term'
   27              0.000086     elseif group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let group = 'airline_c'. self._context.bufnr
   27              0.000085     elseif prev_group ==# 'airline_c' && !self._context.active && has_key(self._context, 'bufnr')
                                  let prev_group = 'airline_c'. self._context.bufnr
   27              0.000013     endif
   27              0.000025     if is_empty
                                  let prev_group = pgroup
   27              0.000013     endif
   27   0.000637   0.000275     let is_empty = s:section_is_empty(self, contents)
                            
   27              0.000024     if is_empty
                                  " need to fix highlighting groups, since we
                                  " have skipped a section, we actually need
                                  " the previous previous group and so the
                                  " seperator goes from the previous previous group
                                  " to the current group
                                  let pgroup = group
   27              0.000013     endif
                            
   27              0.000033     if group == ''
                                  let line .= contents
   27              0.000033     elseif group == '|'
    3              0.000003       let side = 0
    3              0.000008       let line .= contents
    3              0.000003       let split = 1
   24              0.000013     else
   24              0.000030       if prev_group == ''
    3              0.000011         let line .= '%#'.group.'#'
   21              0.000018       elseif split
    3              0.000003         if !is_empty
    3   0.002350   0.000044           let line .= s:get_transitioned_seperator(self, prev_group, group, side)
    3              0.000002         endif
    3              0.000003         let split = 0
   18              0.000009       else
   18              0.000017         if !is_empty
   18   0.020506   0.000195           let line .= s:get_seperator(self, prev_group, group, side)
   18              0.000010         endif
   24              0.000015       endif
   24   0.001685   0.000326       let line .= is_empty ? '' : s:get_accented_line(self, group, contents)
   27              0.000014     endif
                            
   27              0.000035     let i = i + 1
   30              0.000027   endwhile
                            
    3              0.000004   if !self._context.active
                                "let line = substitute(line, '%#airline_c#', '%#airline_c'.self._context.bufnr.'#', '')
                                let line = substitute(line, '%#.\{-}\ze#', '\0_inactive', 'g')
    3              0.000001   endif
    3              0.000003   return line

FUNCTION  <SNR>161_group_not_done()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 26
Called 462 times
Total time:   0.003734
 Self time:   0.003734

count  total (s)   self (s)
  462              0.001402   if index(a:list, a:name) == -1
  378              0.001056     call add(a:list, a:name)
  378              0.000312     return 1
   84              0.000039   else
   84              0.000077     if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
   84              0.000042     endif
   84              0.000056     return 0
                              endif

FUNCTION  <SNR>165_update_untracked()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 192
Called 132 times
Total time:   0.019917
 Self time:   0.017692

count  total (s)   self (s)
  132              0.004794   let file = expand("%:p")
  132              0.001385   if empty(file) || isdirectory(file) || !empty(&buftype)
                                return
  132              0.000083   endif
                            
  132              0.000277   let needs_update = 1
  132              0.000838   let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
  396              0.000838   for vcs in keys(s:vcs_config)
  264              0.001413     if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
  264              0.000162     endif
  264              0.001079     if has_key(s:vcs_config[vcs].untracked, file)
  132              0.000217       let needs_update = 0
  132   0.004945   0.002721       call airline#extensions#branch#update_untracked_config(file, vcs)
  264              0.000162     endif
  396              0.000354   endfor
                            
  132              0.000173   if !needs_update
  132              0.000106     return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>169_conflict_marker()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 52
Called 5 times
Total time:   0.002587
 Self time:   0.002587

count  total (s)   self (s)
                              " Checks for git conflict markers
    5              0.000014   let annotation = '\%([0-9A-Za-z_.:]\+\)\?'
    5              0.000017   if &ft is# 'rst'
                                " rst filetypes use '=======' as header
                                let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(>\{7\} '.annotation.'\)\)$'
    5              0.000003   else
    5              0.000035     let pattern = '^\%(\%(<\{7} '.annotation. '\)\|\%(=\{7\}\)\|\%(>\{7\} '.annotation.'\)\)$'
    5              0.000003   endif
    5              0.002480   return search(pattern, 'nw')

FUNCTION  gitgutter#diff#process_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 231
Called 8 times
Total time:   0.026503
 Self time:   0.001575

count  total (s)   self (s)
    8              0.000019   let modified_lines = []
  104              0.000121   for hunk in a:hunks
   96   0.026221   0.001293     call extend(modified_lines, s:process_hunk(a:bufnr, hunk))
  104              0.000073   endfor
    8              0.000010   return modified_lines

FUNCTION  airline#util#shorten()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 28
Called 528 times
Total time:   0.019580
 Self time:   0.013662

count  total (s)   self (s)
  528   0.013031   0.007113   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return '…'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'…'
                                endif
  528              0.000288   else
  528              0.000657     return a:text
                              endif

FUNCTION  <SNR>179_setup_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 156
Called 11 times
Total time:   0.001280
 Self time:   0.000276

count  total (s)   self (s)
   11   0.001265   0.000261   if gitgutter#utility#has_repo_path(a:bufnr) | return | endif
                            
                              return gitgutter#utility#set_repo_path(a:bufnr, a:continuation)

FUNCTION  <SNR>94_IsBlock()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 325
Called 1 time
Total time:   0.109450
 Self time:   0.000088

count  total (s)   self (s)
    1   0.000098   0.000009   let tok = s:PreviousToken()
    1   0.109321   0.000048   if join(s:stack) =~? 'xml\|jsx' && s:SynAt(line('.'),col('.')-1) =~? 'xml\|jsx'
                                let s:in_jsx = 1
                                return tok != '{'
    1              0.000004   elseif tok =~ '\k'
                                if tok ==# 'type'
                                  return s:Pure('eval',"s:PreviousToken() !~# '^\\%(im\\|ex\\)port$' || s:PreviousToken() == '.'")
                                elseif tok ==# 'of'
                                  return s:Pure('eval',"!s:GetPair('[[({]','[])}]','bW',s:skip_expr) || s:LookingAt() != '(' ||" ."s:{s:PreviousToken() ==# 'await' ? 'Previous' : ''}Token() !=# 'for' || s:PreviousToken() == '.'")
                                endif
                                return index(split('return const let import export extends yield default delete var await void typeof throw case new in instanceof') ,tok) < (line('.') != a:firstline) || s:Pure('s:PreviousToken') == '.'
    1              0.000002   elseif tok == '>'
    1              0.000007     return getline('.')[col('.')-2] == '=' || s:SynAt(line('.'),col('.')) =~? 'jsflow\|^html'
                              elseif tok == '*'
                                return s:Pure('s:PreviousToken') == ':'
                              elseif tok == ':'
                                return s:Pure('eval',"s:PreviousToken() =~ '^\\K\\k*$' && !s:ExprCol()")
                              elseif tok == '/'
                                return s:SynAt(line('.'),col('.')) =~? 'regex'
                              elseif tok !~ '[=~!<,.?^%|&([]'
                                return tok !~ '[-+]' || line('.') != a:firstline && getline('.')[col('.')-2] == tok
                              endif

FUNCTION  <SNR>94_SkipFunc()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 110
Called 3 times
Total time:   0.000594
 Self time:   0.000563

count  total (s)   self (s)
    3              0.000005   if s:top_col == 1
                                throw 'out of bounds'
    3              0.000003   elseif s:check_in
                                if eval(s:skip_expr)
                                  return 1
                                endif
                                let s:check_in = 0
    3              0.000062   elseif getline('.') =~ '\%<'.col('.').'c\/.\{-}\/\|\%>'.col('.').'c[''"]\|\\$'
    2   0.000087   0.000056     if eval(s:skip_expr)
    2              0.000002       return 1
                                endif
    1              0.000393   elseif search('\m`\|\${\|\*\/','nW'.s:z,s:looksyn)
                                if eval(s:skip_expr)
                                  let s:check_in = 1
                                  return 1
                                endif
    1              0.000001   else
    1              0.000006     let s:synid_cache[:] += [[line2byte('.') + col('.') - 1], ['']]
    1              0.000001   endif
    1              0.000005   let [s:looksyn, s:top_col] = getpos('.')[1:2]

FUNCTION  <SNR>165_update_hg_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 138
Called 132 times
Total time:   0.010172
 Self time:   0.009064

count  total (s)   self (s)
  132   0.002556   0.001448   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
  132              0.000081   else
  132              0.000391     let s:vcs_config['mercurial'].branch = ''
  132              0.000084   endif

FUNCTION  airline#extensions#default#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim line 79
Called 3 times
Total time:   0.003472
 Self time:   0.000269

count  total (s)   self (s)
    3              0.000006   let winnr = a:context.winnr
    3              0.000005   let active = a:context.active
                            
    3   0.000071   0.000059   if airline#util#getwinvar(winnr, 'airline_render_left', active || (!active && !g:airline_inactive_collapse))
    3   0.000996   0.000037     call s:build_sections(a:builder, a:context, s:layout[0])
                              else
                                let text = s:get_section(winnr, 'c')
                                if empty(text)
                                  let text = ' %f%m '
                                endif
                                call a:builder.add_section('airline_c'.(a:context.bufnr), text)
    3              0.000001   endif
                            
    3   0.000170   0.000040   call a:builder.split(s:get_section(winnr, 'gutter', '', ''))
                            
    3   0.000062   0.000052   if airline#util#getwinvar(winnr, 'airline_render_right', 1)
    3   0.002119   0.000030     call s:build_sections(a:builder, a:context, s:layout[1])
    3              0.000001   endif
                            
    3              0.000002   return 1

FUNCTION  airline#util#stl_disabled()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 185
Called 6 times
Total time:   0.000258
 Self time:   0.000194

count  total (s)   self (s)
                              " setting the statusline is disabled,
                              " either globally, per window, or per buffer
                              " w:airline_disabled is deprecated!
    6   0.000248   0.000184   return get(g:, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disable_statusline', 0) || airline#util#getwinvar(a:winnr, 'airline_disabled', 0) || airline#util#getbufvar(winbufnr(a:winnr), 'airline_disable_statusline', 0)

FUNCTION  FugitiveVimPath()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 301
Called 132 times
Total time:   0.000998
 Self time:   0.000998

count  total (s)   self (s)
  132              0.000376   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
  132              0.000081   else
  132              0.000163     return a:path
                              endif

FUNCTION  airline#highlighter#add_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 214
Called 21 times
Total time:   0.014849
 Self time:   0.000439

count  total (s)   self (s)
   21              0.000125   let s:separators[a:from.a:to] = [a:from, a:to, a:inverse]
   21   0.014710   0.000301   call <sid>exec_separator({}, a:from, a:to, a:inverse, '')

FUNCTION  <SNR>177_add_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim line 47
Called 24 times
Total time:   0.002618
 Self time:   0.000866

count  total (s)   self (s)
   24              0.000108     let condition = (a:key is# "warning" || a:key is# "error") && (v:version == 704 && !has("patch1511"))
                                " i have no idea why the warning section needs special treatment, but it's
                                " needed to prevent separators from showing up
   24   0.000507   0.000166     if ((a:key == 'error' || a:key == 'warning') && empty(s:get_section(a:context.winnr, a:key)))
                                  return
   24              0.000010     endif
   24              0.000020     if condition
                                  call a:builder.add_raw('%(')
   24              0.000011     endif
   24   0.001777   0.000365     call a:builder.add_section('airline_'.a:key, s:get_section(a:context.winnr, a:key))
   24              0.000023     if condition
                                  call a:builder.add_raw('%)')
   24              0.000012     endif

FUNCTION  airline#util#wrap()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 42
Called 1716 times
Total time:   0.015540
 Self time:   0.012628

count  total (s)   self (s)
 1716   0.009913   0.007001   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
 1716              0.000890   endif
 1716              0.001947   return a:text

FUNCTION  airline#parts#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 49
Called 264 times
Total time:   0.001199
 Self time:   0.001199

count  total (s)   self (s)
  264              0.001073   return get(s:parts, a:key, {})

FUNCTION  gitgutter#debug#log()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/debug.vim line 70
Called 16 times
Total time:   0.000878
 Self time:   0.000878

count  total (s)   self (s)
   16              0.000036   if g:gitgutter_log
                                if s:new_log_session && gitgutter#async#available()
                                  if exists('*ch_logfile')
                                    call ch_logfile(s:channel_log, 'w')
                                  endif
                                endif
                            
                                execute 'redir >> '.s:log_file
                                  if s:new_log_session
                                    let s:start = reltime()
                                    silent echo "\n==== start log session ===="
                                  endif
                            
                                  let elapsed = reltimestr(reltime(s:start)).' '
                                  silent echo ''
                                  " callers excluding this function
                                  silent echo elapsed.expand('<sfile>')[:-22].':'
                                  silent echo elapsed.s:format_for_log(a:message)
                                  if a:0 && !empty(a:1)
                                    for msg in a:000
                                      silent echo elapsed.s:format_for_log(msg)
                                    endfor
                                  endif
                                redir END
                            
                                let s:new_log_session = 0
   16              0.000013   endif

FUNCTION  FugitiveGitDir()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 11
Called 264 times
Total time:   0.009913
 Self time:   0.008967

count  total (s)   self (s)
  264              0.001124   if !a:0 || type(a:1) == type(0) && a:1 < 0
  132              0.000400     if exists('g:fugitive_event')
                                  return g:fugitive_event
  132              0.000084     endif
  132              0.000456     let dir = get(b:, 'git_dir', '')
  132              0.000547     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
                                  return FugitiveExtractGitDir(getcwd())
  132              0.000078     endif
  132              0.000155     return dir
  132              0.000374   elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
  132              0.000368   elseif type(a:1) == type('')
  132   0.003138   0.002192     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  gitgutter#utility#extension()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 88
Called 8 times
Total time:   0.001435
 Self time:   0.000335

count  total (s)   self (s)
    8   0.001426   0.000326   return fnamemodify(s:abs_path(a:bufnr, 0), ':e')

FUNCTION  <SNR>190_is_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 289
Called 8 times
Total time:   0.000043
 Self time:   0.000043

count  total (s)   self (s)
    8              0.000027   return a:from_count > 0 && a:to_count > 0 && a:from_count > a:to_count

FUNCTION  airline#util#getwinvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 82
Called 51 times
Total time:   0.000179
 Self time:   0.000179

count  total (s)   self (s)
   51              0.000159     return getwinvar(a:winnr, a:key, a:def)

FUNCTION  airline#extensions#whitespace#check()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 64
Called 132 times
Total time:   0.054159
 Self time:   0.026933

count  total (s)   self (s)
  132              0.000668   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
  132              0.000913   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
  132              0.000064   endif
  132              0.001468   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
  132              0.000490   if !exists('b:airline_whitespace_check')
    5              0.000013     let b:airline_whitespace_check = ''
    5              0.000039     let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
    5              0.000008     let trailing = 0
    5              0.000009     let check = 'trailing'
    5              0.000044     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    5              0.000004       try
    5              0.000026         let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
    5              0.008121         let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
    5              0.000006       endtry
    5              0.000003     endif
                            
    5              0.000010     let mixed = 0
    5              0.000009     let check = 'indent'
    5              0.000061     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    5   0.019001   0.000087       let mixed = s:check_mixed_indent()
    5              0.000014     endif
                            
    5              0.000016     let mixed_file = ''
    5              0.000011     let check = 'mixed-indent-file'
    5              0.000069     if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
    5   0.000753   0.000098       let mixed_file = s:check_mixed_indent_file()
    5              0.000003     endif
                            
    5              0.000008     let long = 0
    5              0.000016     if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
    5              0.000003     endif
                            
    5              0.000009     let conflicts = 0
    5              0.000014     if index(checks, 'conflicts') > -1
    5   0.002650   0.000063       let conflicts = s:conflict_marker()
    5              0.000005     endif
                            
    5              0.000029     if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
    5              0.000003     endif
  132              0.000066   endif
  132   0.006506   0.001436   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  gitgutter#hunk#hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 10
Called 8 times
Total time:   0.000201
 Self time:   0.000107

count  total (s)   self (s)
    8   0.000197   0.000103   return gitgutter#utility#getbufvar(a:bufnr, 'hunks', [])

FUNCTION  <SNR>164_is_branch_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 55
Called 132 times
Total time:   0.001140
 Self time:   0.001140

count  total (s)   self (s)
  132              0.001050   return exists('*airline#extensions#branch#head') && empty(get(b:, 'airline_head', ''))

FUNCTION  airline#extensions#hunks#get_raw_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 76
Called 132 times
Total time:   0.015654
 Self time:   0.005410

count  total (s)   self (s)
  132              0.000844   if !exists('b:source_func') || get(b:, 'source_func', '') is# 's:get_hunks_empty'
                                if get(g:, 'loaded_signify') && sy#buffer_is_active()
                                  let b:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let b:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let b:source_func = 's:get_hunks_changes'
                                elseif exists('*quickfixsigns#vcsdiff#GetHunkSummary')
                                  let b:source_func = 'quickfixsigns#vcsdiff#GetHunkSummary'
                                elseif s:coc_git_enabled()
                                  let b:source_func = 's:get_hunks_coc'
                                else
                                  let b:source_func = 's:get_hunks_empty'
                                endif
  132              0.000069   endif
  132   0.012191   0.001947   return {b:source_func}()

FUNCTION  <SNR>195_is_jsx_brace()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 77
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000005   return a:syntax =~? 'jsxBraces'

FUNCTION  <SNR>94_GetVars()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 45
Called 1 time
Total time:   0.000017
 Self time:   0.000017

count  total (s)   self (s)
    1              0.000017   call extend(b:,extend(s:bvars,{'js_cache': [0,0,0]}),'keep')

FUNCTION  <SNR>195_start_syntax()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 36
Called 1 time
Total time:   0.137602
 Self time:   0.000020

count  total (s)   self (s)
    1   0.137601   0.000019   return s:syntax_at(a:lnum, s:start_col(a:lnum))

FUNCTION  <SNR>151_parse_screen()
    Defined: ~/.vim/plugged/vim-css-color/autoload/css_color.vim line 217
Called 55 times
Total time:   0.034177
 Self time:   0.034177

count  total (s)   self (s)
   55              0.000416 	let leftcol = winsaveview().leftcol
   55              0.000249 	let left = max([ leftcol - 15, 0 ])
   55              0.000130 	let width = &columns * 4
   55              0.033288 	call filter( range( line('w0'), line('w$') ), 'substitute( strpart( getline(v:val), col([v:val, left]), width ), b:css_color_pat, ''\=s:create_syn_match()'', ''g'' )' )

FUNCTION  ObsessionStatus()
    Defined: ~/.vim/plugged/vim-obsession/plugin/obsession.vim line 102
Called 132 times
Total time:   0.005608
 Self time:   0.005608

count  total (s)   self (s)
  132              0.000526   let args = copy(a:000)
  132              0.000776   let numeric = !empty(v:this_session) + exists('g:this_obsession')
  132              0.000576   if type(get(args, 0, '')) == type(0)
                                if !remove(args, 0)
                                  return ''
                                endif
  132              0.000067   endif
  132              0.000225   if empty(args)
                                let args = ['[$]', '[S]']
  132              0.000071   endif
  132              0.000314   if len(args) == 1 && numeric == 1
                                let fmt = args[0]
  132              0.000075   else
  132              0.000443     let fmt = get(args, 2-numeric, '')
  132              0.000081   endif
  132              0.001223   return substitute(fmt, '%s', get(['', 'Session', 'Obsession'], numeric), 'g')

FUNCTION  airline#update_statusline_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 156
Called 3 times
Total time:   0.000209
 Self time:   0.000090

count  total (s)   self (s)
    3   0.000144   0.000025   if airline#util#stl_disabled(winnr())
                                return
    3              0.000001   endif
    3              0.000005   for nr in a:range
                                if airline#util#stl_disabled(nr)
                                  continue
                                endif
                                call setwinvar(nr, 'airline_active', 0)
                                let context = { 'winnr': nr, 'active': 0, 'bufnr': winbufnr(nr) }
                                if get(g:, 'airline_inactive_alt_sep', 0)
                                  call extend(context, { 'left_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_alt_sep }, 'keep')
                                endif
                                call s:invoke_funcrefs(context, s:inactive_funcrefs)
    3              0.000006   endfor

FUNCTION  gitgutter#all()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 3
Called 3 times
Total time:   0.033853
 Self time:   0.000857

count  total (s)   self (s)
    3              0.000029   let visible = tabpagebuflist()
                            
    9              0.000055   for bufnr in range(1, bufnr('$') + 1)
    6              0.000039     if buflisted(bufnr)
    3              0.000358       let file = expand('#'.bufnr.':p')
    3              0.000022       if !empty(file)
    3              0.000022         if index(visible, bufnr) != -1
    3   0.033119   0.000123           call gitgutter#process_buffer(bufnr, a:force)
                                    elseif a:force
                                      call s:reset_tick(bufnr)
    3              0.000003         endif
    3              0.000003       endif
    6              0.000013     endif
    9              0.000019   endfor

FUNCTION  <SNR>190_process_modified_and_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 333
Called 8 times
Total time:   0.000359
 Self time:   0.000359

count  total (s)   self (s)
    8              0.000015   let offset = 0
   32              0.000049   while offset < a:to_count
   24              0.000053     let line_number = a:to_line + offset
   24              0.000085     call add(a:modifications, [line_number, 'modified'])
   24              0.000036     let offset += 1
   32              0.000024   endwhile
    8              0.000036   let a:modifications[-1] = [a:to_line + offset - 1, 'modified_removed']

FUNCTION  FugitiveHead()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 128
Called 132 times
Total time:   0.079278
 Self time:   0.003475

count  total (s)   self (s)
  132   0.004570   0.001428   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
  132              0.000245   if empty(dir)
                                return ''
  132              0.000068   endif
  132   0.074127   0.001467   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  coc#rpc#ready()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 31
Called 92 times
Total time:   0.001024
 Self time:   0.001024

count  total (s)   self (s)
   92              0.000607   if empty(s:client) || s:client['running'] == 0
                                return 0
   92              0.000062   endif
   92              0.000095   return 1

FUNCTION  <SNR>23_not_git_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 59
Called 11 times
Total time:   0.003808
 Self time:   0.000514

count  total (s)   self (s)
   11   0.003794   0.000500   return s:dir(a:bufnr) !~ '[/\\]\.git\($\|[/\\]\)'

FUNCTION  airline#parts#ffenc()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 108
Called 132 times
Total time:   0.004779
 Self time:   0.004779

count  total (s)   self (s)
  132              0.000647   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
  132              0.000291   let bomb     = &bomb ? '[BOM]' : ''
  132              0.000462   let noeolf   = &eol ? '' : '[!EOL]'
  132              0.000907   let ff       = strlen(&ff) ? '['.&ff.']' : ''
  132              0.001373   if expected is# &fenc.bomb.noeolf.ff
                                return ''
  132              0.000073   else
  132              0.000676     return &fenc.bomb.noeolf.ff
                              endif

FUNCTION  airline#extensions#branch#head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 239
Called 132 times
Total time:   0.139173
 Self time:   0.005773

count  total (s)   self (s)
  132              0.000480   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
  132              0.000081   endif
                            
  132   0.114792   0.001535   call s:update_branch()
  132   0.021596   0.001679   call s:update_untracked()
                            
  132              0.000715   if exists('b:airline_head') && !empty(b:airline_head)
  129              0.000196     return b:airline_head
    3              0.000001   endif
                            
    3              0.000005   let b:airline_head = ''
    3              0.000014   let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
    3              0.000004   let heads = []
    9              0.000010   for vcs in vcs_priority
    6              0.000016     if !empty(b:buffer_vcs_config[vcs].branch)
    3              0.000007       let heads += [vcs]
    6              0.000003     endif
    9              0.000006   endfor
                            
    6              0.000007   for vcs in heads
    3              0.000006     if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
    3              0.000001     endif
    3              0.000005     if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
    3              0.000001     endif
    3   0.000287   0.000061     let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
    3              0.000008     let additional = b:buffer_vcs_config[vcs].untracked
    3              0.000016     if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
    3              0.000009       let additional = g:airline_symbols['dirty']
    3              0.000002     endif
    3              0.000007     let b:airline_head .= additional
    6              0.000006   endfor
                            
    3              0.000005   if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
    3              0.000001   endif
                            
    3              0.000005   if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
    3              0.000001   endif
                            
    3              0.000012   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  '…' : '.')
                                endif
    3              0.000001   endif
                            
    3              0.000004   return b:airline_head

FUNCTION  airline#extensions#ctrlp#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/ctrlp.vim line 70
Called 3 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
                              " disable statusline overwrite if ctrlp already did it
    3              0.000044   return match(&statusline, 'CtrlPwhite') >= 0 ? -1 : 0

FUNCTION  <SNR>190_process_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 302
Called 8 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    8              0.000011   if a:to_line == 0
                                call add(a:modifications, [1, 'removed_first_line'])
    8              0.000005   else
    8              0.000031     call add(a:modifications, [a:to_line, 'removed'])
    8              0.000005   endif

FUNCTION  gitgutter#utility#shellescape()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 73
Called 35 times
Total time:   0.002643
 Self time:   0.002454

count  total (s)   self (s)
   35              0.001910   if a:arg =~ '^[A-Za-z0-9_/.-]\+$'
   27              0.000090     return a:arg
    8   0.000353   0.000165   elseif s:winshell()
                                return '"' . substitute(substitute(a:arg, '"', '""', 'g'), '%', '"%"', 'g') . '"'
    8              0.000012   else
    8              0.000116     return shellescape(a:arg)
                              endif

FUNCTION  airline#util#ignore_buf()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 136
Called 132 times
Total time:   0.005115
 Self time:   0.005115

count  total (s)   self (s)
  132              0.001476   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
  132              0.003521   return match(a:name, pat) > -1

FUNCTION  gitgutter#async#available()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 11
Called 8 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    8              0.000023   return s:available

FUNCTION  <SNR>190_is_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 277
Called 88 times
Total time:   0.000218
 Self time:   0.000218

count  total (s)   self (s)
   88              0.000182   return a:from_count > 0 && a:to_count == 0

FUNCTION  gitgutter#diff#parse_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 216
Called 96 times
Total time:   0.003400
 Self time:   0.003400

count  total (s)   self (s)
   96              0.001475   let matches = matchlist(a:line, s:hunk_re)
   96              0.000191   if len(matches) > 0
   96              0.000304     let from_line  = str2nr(matches[1])
   96              0.000380     let from_count = (matches[2] == '') ? 1 : str2nr(matches[2])
   96              0.000263     let to_line    = str2nr(matches[3])
   96              0.000363     let to_count   = (matches[4] == '') ? 1 : str2nr(matches[4])
   96              0.000266     return [from_line, from_count, to_line, to_count]
                              else
                                return []
                              end

FUNCTION  airline#builder#get_prev_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 37
Called 27 times
Total time:   0.000293
 Self time:   0.000293

count  total (s)   self (s)
   27              0.000044   let x = a:i - 1
   30              0.000034   while x >= 0
   27              0.000061     let group = a:sections[x][0]
   27              0.000056     if group != '' && group != '|'
   24              0.000025       return group
    3              0.000002     endif
    3              0.000004     let x = x - 1
    6              0.000005   endwhile
    3              0.000002   return ''

FUNCTION  <SNR>177_build_sections()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim line 35
Called 6 times
Total time:   0.003049
 Self time:   0.000431

count  total (s)   self (s)
   30              0.000036   for key in a:keys
   24              0.000070     if (key == 'warning' || key == 'error') && !a:context.active
                                  continue
   24              0.000011     endif
   24   0.002851   0.000233     call s:add_section(a:builder, a:context, key)
   30              0.000021   endfor

FUNCTION  <SNR>191_handle_double_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim line 212
Called 8 times
Total time:   0.000107
 Self time:   0.000107

count  total (s)   self (s)
    8              0.000060   if a:modified_lines[0:1] == [[1, 'removed_first_line'], [1, 'removed']]
                                return [[1, 'removed_above_and_below']] + a:modified_lines[2:]
    8              0.000005   endif
                            
    8              0.000010   return a:modified_lines

FUNCTION  airline#util#ignore_next_focusgain()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 195
Called 135 times
Total time:   0.001241
 Self time:   0.001241

count  total (s)   self (s)
  135              0.000602   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
  135              0.000085   endif

FUNCTION  <SNR>166_ModifierFlags()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim line 11
Called 132 times
Total time:   0.000572
 Self time:   0.000572

count  total (s)   self (s)
  132              0.000501   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  CocActionAsync()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 82
Called 8 times
Total time:   0.004620
 Self time:   0.000549

count  total (s)   self (s)
    8   0.004590   0.000519   return s:AsyncRequest(a:name, a:000)

FUNCTION  airline#parts#paste()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 63
Called 132 times
Total time:   0.000491
 Self time:   0.000491

count  total (s)   self (s)
  132              0.000415   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  airline#update_statusline()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 127
Called 3 times
Total time:   0.032984
 Self time:   0.000237

count  total (s)   self (s)
    3   0.000168   0.000029   if airline#util#stl_disabled(winnr())
                                return
    3              0.000002   endif
    3              0.000033   let range = filter(range(1, winnr('$')), 'v:val != winnr()')
                              " create inactive statusline
    3   0.000240   0.000031   call airline#update_statusline_inactive(range)
                            
    3              0.000005   unlet! w:airline_render_left w:airline_render_right
    3              0.000047   exe 'unlet! ' 'w:airline_section_'. join(s:sections, ' w:airline_section_')
                            
                              " Now create the active statusline
    3              0.000006   let w:airline_active = 1
    3              0.000017   let context = { 'winnr': winnr(), 'active': 1, 'bufnr': winbufnr(winnr()) }
    3   0.032453   0.000054   call s:invoke_funcrefs(context, g:airline_statusline_funcrefs)

FUNCTION  gitgutter#diff#run_diff()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 71
Called 8 times
Total time:   0.095875
 Self time:   0.005556

count  total (s)   self (s)
    8   0.000520   0.000158   if gitgutter#utility#repo_path(a:bufnr, 0) == -1
                                throw 'gitgutter author fail'
    8              0.000009   endif
                            
    8   0.000548   0.000173   if gitgutter#utility#repo_path(a:bufnr, 0) == -2
                                throw 'gitgutter not tracked'
    8              0.000008   endif
                            
                              " Wrap compound commands in parentheses to make Windows happy.
                              " bash doesn't mind the parentheses.
    8              0.000021   let cmd = '('
                            
                              " Append buffer number to temp filenames to avoid race conditions between
                              " writing and reading the files when asynchronously processing multiple
                              " buffers.
                            
                              " Without the buffer number, buff_file would have a race between the
                              " second gitgutter#process_buffer() writing the file (synchronously, below)
                              " and the first gitgutter#process_buffer()'s async job reading it (with
                              " git-diff).
    8              0.000055   let buff_file = s:temp_buffer.'.'.a:bufnr
                            
                              " Add a counter to avoid a similar race with two quick writes of the same buffer.
                              " Use a modulus greater than a maximum reasonable number of visible buffers.
    8              0.000039   let s:counter = (s:counter + 1) % 20
    8              0.000059   let buff_file .= '.'.s:counter
                            
    8   0.001630   0.000195   let extension = gitgutter#utility#extension(a:bufnr)
    8              0.000033   if !empty(extension)
    8              0.000043     let buff_file .= '.'.extension
    8              0.000009   endif
                            
                              " Write buffer to temporary file.
                              " Note: this is synchronous.
    8   0.009636   0.001018   call s:write_buffer(a:bufnr, buff_file)
                            
    8              0.000037   if a:from ==# 'index'
                                " Without the buffer number, from_file would have a race in the shell
                                " between the second process writing it (with git-show) and the first
                                " reading it (with git-diff).
    8              0.000076     let from_file = s:temp_from.'.'.a:bufnr
                            
                                " Add a counter to avoid a similar race with two quick writes of the same buffer.
    8              0.000049     let from_file .= '.'.s:counter
                            
    8              0.000054     if !empty(extension)
    8              0.000049       let from_file .= '.'.extension
    8              0.000011     endif
                            
                                " Write file from index to temporary file.
    8   0.003326   0.000494     let index_name = gitgutter#utility#get_diff_base(a:bufnr).':'.gitgutter#utility#repo_path(a:bufnr, 1)
    8              0.000265     let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager show '.index_name.' > '.from_file.' && '
                            
                              elseif a:from ==# 'working_tree'
                                let from_file = gitgutter#utility#repo_path(a:bufnr, 1)
    8              0.000013   endif
                            
                              " Call git-diff.
    8              0.000096   let cmd .= g:gitgutter_git_executable.' '.g:gitgutter_git_args.' --no-pager'
    8              0.000022   if s:c_flag
    8              0.000053     let cmd .= ' -c "diff.autorefreshindex=0"'
    8              0.000048     let cmd .= ' -c "diff.noprefix=false"'
    8              0.000062     let cmd .= ' -c "core.safecrlf=false"'
    8              0.000012   endif
    8              0.000194   let cmd .= ' diff --no-ext-diff --no-color -U0 '.g:gitgutter_diff_args.' -- '.from_file.' '.buff_file
                            
                              " Pipe git-diff output into grep.
    8              0.000081   if !a:preserve_full_diff && !empty(g:gitgutter_grep)
    8   0.001050   0.000277     let cmd .= ' | '.g:gitgutter_grep.' '.gitgutter#utility#shellescape('^@@ ')
    8              0.000012   endif
                            
                              " grep exits with 1 when no matches are found; git-diff exits with 1 when
                              " differences are found.  However we want to treat non-matches and
                              " differences as non-erroneous behaviour; so we OR the command with one
                              " which always exits with success (0).
    8              0.000044   let cmd .= ' || exit 0'
                            
    8              0.000037   let cmd .= ')'
                            
    8   0.004285   0.000270   let cmd = gitgutter#utility#cd_cmd(a:bufnr, cmd)
                            
    8   0.000222   0.000186   if g:gitgutter_async && gitgutter#async#available()
    8   0.072363   0.000491     call gitgutter#async#execute(cmd, a:bufnr, {   'out': function('gitgutter#diff#handler'),   'err': function('gitgutter#hunk#reset'), })
    8              0.000116     return 'async'
                            
                              else
                                let diff = gitgutter#utility#system(cmd)
                            
                                if v:shell_error
                                  call gitgutter#debug#log(diff)
                                  throw 'gitgutter diff failed'
                                endif
                            
                                return diff
                              endif

FUNCTION  <SNR>190_write_buffer()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 375
Called 8 times
Total time:   0.008618
 Self time:   0.008618

count  total (s)   self (s)
    8              0.001508   let bufcontents = getbufline(a:bufnr, 1, '$')
                            
    8              0.000060   if bufcontents == [''] && line2byte(1) == -1
                                " Special case: completely empty buffer.
                                " A nearly empty buffer of only a newline has line2byte(1) == 1.
                                call writefile([], a:file)
                                return
    8              0.000009   endif
                            
    8              0.000076   if getbufvar(a:bufnr, '&fileformat') ==# 'dos'
                                call map(bufcontents, 'v:val."\r"')
    8              0.000008   endif
                            
    8              0.000059   if getbufvar(a:bufnr, '&endofline')
    8              0.000073     call add(bufcontents, '')
    8              0.000009   endif
                            
    8              0.000053   let fenc = getbufvar(a:bufnr, '&fileencoding')
    8              0.000040   if fenc !=# &encoding
                                call map(bufcontents, 'iconv(v:val, &encoding, "'.fenc.'")')
    8              0.000009   endif
                            
    8              0.000034   if getbufvar(a:bufnr, '&bomb')
                                let bufcontents[0]='﻿'.bufcontents[0]
    8              0.000008   endif
                            
                              " The file we are writing to is a temporary file.  Sometimes the parent
                              " directory is deleted outside Vim but, because Vim caches the directory
                              " name at startup and does not check for its existence subsequently, Vim
                              " does not realise.  This causes E482 errors.
    8              0.000010   try
    8              0.006195     call writefile(bufcontents, a:file, 'b')
                              catch /E482/
                                call mkdir(fnamemodify(a:file, ':h'), '', '0700')
                                call writefile(bufcontents, a:file, 'b')
    8              0.000022   endtry

FUNCTION  <SNR>195_prev_lnum()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 97
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000006   return prevnonblank(a:lnum - 1)

FUNCTION  <SNR>187_delayed_checktime()
    Defined: ~/.vim/plugged/vim-tmux-focus-events/autoload/tmux_focus_events.vim line 14
Called 1 time
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
    1              0.000001   try
    1              0.000003     silent checktime
                                " clearing out 'emergency' events, if the checktime succeeded
    1              0.000001     augroup focus_gained_checktime
    1              0.000245       au!
    1              0.000001     augroup END
                              catch /E523/  " Not allowed here: silent checktime
                              catch /E11/   " Invalid in command-line window
                                " don't clear the augroup, let it fire again when possible
    1              0.000001   endtry

FUNCTION  <SNR>191_highlight_name_for_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim line 234
Called 592 times
Total time:   0.004095
 Self time:   0.004095

count  total (s)   self (s)
  592              0.000950   if a:text ==# 'added'
  344              0.000473     return 'GitGutterLineAdded'
  248              0.000374   elseif a:text ==# 'removed'
    8              0.000012     return 'GitGutterLineRemoved'
  240              0.000448   elseif a:text ==# 'removed_first_line'
                                return 'GitGutterLineRemovedFirstLine'
  240              0.000363   elseif a:text ==# 'modified'
  232              0.000342     return 'GitGutterLineModified'
    8              0.000015   elseif a:text ==# 'modified_removed'
    8              0.000014     return 'GitGutterLineModifiedRemoved'
                              elseif a:text ==# 'removed_above_and_below'
                                return 'GitGutterLineRemovedAboveAndBelow'
                              endif

FUNCTION  fugitive#CommonDir()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 256
Called 132 times
Total time:   0.004077
 Self time:   0.004077

count  total (s)   self (s)
  132              0.000305   if empty(a:dir)
                                return ''
  132              0.000071   endif
  132              0.000475   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
  132              0.000066   endif
  132              0.000338   return s:commondirs[a:dir]

FUNCTION  airline#parts#readonly()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 89
Called 132 times
Total time:   0.008451
 Self time:   0.003336

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
  132   0.006935   0.001820   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
  132              0.000084   endif
  132              0.000491   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
  132              0.000077   else
  132              0.000263     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 497
Called 132 times
Total time:   0.072661
 Self time:   0.011137

count  total (s)   self (s)
  132              0.000519   let dir = a:0 > 1 ? a:2 : s:Dir()
  132              0.000248   if empty(dir)
                                return ''
  132              0.000068   endif
  132   0.063068   0.001544   let file = fugitive#Find('.git/HEAD', dir)
  132              0.002868   let ftime = getftime(file)
  132              0.000213   if ftime == -1
                                return ''
  132              0.000712   elseif ftime != get(s:head_cache, dir, [-1])[0]
    3              0.000076     let s:head_cache[dir] = [ftime, readfile(file)[0]]
  132              0.000091   endif
  132              0.000436   let head = s:head_cache[dir][1]
  132              0.000804   if head =~# '^ref: '
  132              0.002592     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>94_PreviousToken()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 169
Called 40 times
Total time:  83.229174
 Self time:   0.224602

count  total (s)   self (s)
   40              0.000227   let [l:pos, tok] = [getpos('.'), '']
   40              0.000652   if search('\m\k\{1,}\|\S','ebW')
   40              0.000240     if getline('.')[col('.')-2:col('.')-1] == '*/'
                                  if eval(s:in_comm) && !s:SearchLoop('\S\ze\_s*\/[/*]','bW',s:in_comm)
                                    call setpos('.',l:pos)
                                  else
                                    let tok = s:Token()
                                  endif
   40              0.000022     else
   40              0.000291       let two = a:0 || line('.') != l:pos[1] ? strridx(getline('.')[:col('.')],'//') + 1 : 0
   40   4.309931   0.000999       if two && eval(s:in_comm)
   38              0.000179         call cursor(0,two)
   38              0.000251         let tok = s:PreviousToken(1)
   38              0.000043         if tok is ''
                                      call setpos('.',l:pos)
   38              0.000018         endif
    2              0.000001       else
    2   0.000086   0.000029         let tok = s:Token()
   40              0.000019       endif
   40              0.000017     endif
   40              0.000017   endif
   40              0.000033   return tok

FUNCTION  <SNR>184_Tree()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 281
Called 132 times
Total time:   0.013239
 Self time:   0.001602

count  total (s)   self (s)
  132   0.013151   0.001514   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  gitgutter#utility#setbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 9
Called 136 times
Total time:   0.002308
 Self time:   0.002308

count  total (s)   self (s)
  136              0.000250   let buffer = +a:buffer
                              " Default value for getbufvar() was introduced in Vim 7.3.831.
  136              0.000434   let ggvars = getbufvar(buffer, 'gitgutter')
  136              0.000361   if type(ggvars) == type('')
                                unlet ggvars
                                let ggvars = {}
                                call setbufvar(buffer, 'gitgutter', ggvars)
  136              0.000077   endif
  136              0.000401   let ggvars[a:varname] = a:val

FUNCTION  <SNR>187_cursor_in_cmd_line()
    Defined: ~/.vim/plugged/vim-tmux-focus-events/autoload/tmux_focus_events.vim line 8
Called 3 times
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    3              0.000028   let in_cmd_line = !empty(getcmdtype())
    3              0.000021   let in_cmd_window = s:has_getcmdwintype && !empty(getcmdwintype())
    3              0.000009   return in_cmd_line || in_cmd_window

FUNCTION  <SNR>169_check_mixed_indent()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 17
Called 5 times
Total time:   0.018914
 Self time:   0.018914

count  total (s)   self (s)
    5              0.000038   let indent_algo = get(g:, 'airline#extensions#whitespace#mixed_indent_algo', 0)
    5              0.000008   if indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less than tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
    5              0.000007   elseif indent_algo == 2
                                return search('\v(^\t* +\t\s*\S)', 'nw', 0, 500)
    5              0.000003   else
    5              0.018796     return search('\v(^\t+ +)|(^ +\t+)', 'nw', 0, 500)
                              endif

FUNCTION  airline#extensions#obsession#get_status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/obsession.vim line 21
Called 132 times
Total time:   0.007384
 Self time:   0.001776

count  total (s)   self (s)
  132   0.007316   0.001708   return ObsessionStatus((g:airline#extensions#obsession#indicator_text . s:spc), '')

FUNCTION  airline#extensions#nvimlsp#get()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim line 16
Called 264 times
Total time:   0.001987
 Self time:   0.001987

count  total (s)   self (s)
  264              0.001549   if !exists("v:lua.vim.lsp.buf_get_clients()") ||  empty(v:lua.vim.lsp.buf_get_clients(0))
  264              0.000231     return ''
                              endif
                            
                              let error_symbol = get(g:, 'airline#extensions#nvimlsp#error_symbol', 'E:')
                              let warning_symbol = get(g:, 'airline#extensions#nvimlsp#warning_symbol', 'W:')
                            
                              let is_err = a:type ==# 'Error'
                            
                              let symbol = is_err ? error_symbol : warning_symbol
                            
                              if luaeval("pcall(require, 'vim.lsp.diagnostic')")
                                let num = v:lua.vim.lsp.diagnostic.get_count(0, a:type)
                              else
                                let num = v:lua.vim.lsp.util.buf_diagnostics_count(a:type)
                              endif
                            
                              return s:airline_nvimlsp_count(num, symbol)

FUNCTION  <SNR>195_start_col()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 31
Called 2 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    2              0.000048   return len(matchstr(getline(a:lnum), '^\s*')) + 1

FUNCTION  <SNR>188_on_stderr_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 66
Called 8 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    8              0.000020   if a:data != ['']  " With Neovim there is always [''] reported on stderr.
                                call self.handler.err(self.buffer)
    8              0.000005   endif

FUNCTION  airline#builder#should_change_group()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 130
Called 18 times
Total time:   0.006485
 Self time:   0.000604

count  total (s)   self (s)
   18              0.000035   if a:group1 == a:group2
                                return 0
   18              0.000008   endif
   18   0.003275   0.000219   let color1 = airline#highlighter#get_highlight(a:group1)
   18   0.003064   0.000238   let color2 = airline#highlighter#get_highlight(a:group2)
   18              0.000070   return color1[1] != color2[1] || color1[0] != color2[0] ||  color1[2] != color2[2] || color1[3] != color2[3]

FUNCTION  airline#check_mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 199
Called 132 times
Total time:   0.301672
 Self time:   0.021101

count  total (s)   self (s)
  132              0.000551   if !has_key(s:contexts, a:winnr)
                                return ''
  132              0.000116   endif
  132              0.000488   let context = s:contexts[a:winnr]
                            
  132              0.000481   if get(w:, 'airline_active', 1)
  132              0.000426     let l:m = mode(1)
  132              0.000276     if l:m ==# "i"
                                  let l:mode = ['insert']
  132              0.000313     elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
  132              0.000199     elseif l:m ==# "Rv"
                                  let l:mode =['replace']
  132              0.000229     elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
  132              0.001679     elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
  132              0.000195     elseif l:m ==# "t"
                                  let l:mode = ['terminal']
  132              0.000270     elseif l:m[0] ==# "c"
   11              0.000026       let l:mode = ['commandline']
  121              0.000187     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
  121              0.000257     elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['insert']
                                  let l:m = 'ni'
  121              0.000082     else
  121              0.000272       let l:mode = ['normal']
  132              0.000086     endif
  132              0.000741     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
  132              0.000084     endif
  132              0.000980     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
  132              0.000305       let l:m = l:m[0]
  132              0.000084     endif
  132              0.000765     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
                              else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
  132              0.000085   endif
                            
  132              0.000485   if g:airline_detect_modified && &modified
   48              0.000172     call add(l:mode, 'modified')
  132              0.000084   endif
                            
  132              0.000274   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
  132              0.000078   endif
                            
  132              0.000930   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
  132              0.000075   endif
                            
  132              0.000258   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
  132              0.000074   endif
                            
  132              0.000227   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
  132              0.000074   endif
                            
  132              0.000658   let mode_string = join(l:mode)
  132              0.000656   if get(w:, 'airline_lastmode', '') != mode_string
   23   0.010573   0.000515     call airline#highlighter#highlight_modified_inactive(context.bufnr)
   23   0.268440   0.000474     call airline#highlighter#highlight(l:mode, context.bufnr)
   23   0.002788   0.000241     call airline#util#doautocmd('AirlineModeChanged')
   23              0.000059     let w:airline_lastmode = mode_string
  132              0.000075   endif
                            
  132              0.000127   return ''

FUNCTION  <SNR>17_airline_refresh()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 216
Called 3 times
Total time:   0.033886
 Self time:   0.000175

count  total (s)   self (s)
                              " a:1, fast refresh, do not reload the theme
    3              0.000014   let fast=!empty(get(a:000, 0, 0))
    3              0.000010   if !exists("#airline")
                                " disabled
                                return
    3              0.000002   endif
    3   0.000529   0.000033   call airline#util#doautocmd('AirlineBeforeRefresh')
    3   0.000243   0.000036   call airline#highlighter#reset_hlcache()
    3              0.000004   if !fast
                                call airline#load_theme()
    3              0.000002   endif
    3   0.033013   0.000030   call airline#update_statusline()
    3   0.000054   0.000030   call airline#update_tabline()

FUNCTION  <SNR>165_display_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 115
Called 3 times
Total time:   0.000218
 Self time:   0.000139

count  total (s)   self (s)
                              " disable FocusGained autocommand, might cause loops because system() causes
                              " a refresh, which causes a system() command again #2029
    3   0.000047   0.000028   call airline#util#ignore_next_focusgain()
    3              0.000007   let name = b:buffer_vcs_config['git'].branch
    3              0.000002   try
    3   0.000095   0.000034     let commit = matchstr(FugitiveParse()[0], '^\x\+')
                            
    3              0.000007     if has_key(s:names, commit)
                                  let name = get(s:names, commit)."(".name.")"
    3              0.000005     elseif !empty(commit)
                                  let ref = fugitive#repo().git_chomp('describe', '--all', '--exact-match', commit)
                                  if ref !~ "^fatal: no tag exactly matches"
                                    let name = s:format_name(substitute(ref, '\v\C^%(heads/|remotes/|tags/)=','',''))."(".name.")"
                                  else
                                    let name = matchstr(commit, '.\{'.s:sha1size.'}')."(".name.")"
                                  endif
    3              0.000001     endif
                              catch
    3              0.000002   endtry
    3              0.000003   return name

FUNCTION  fugitive#ReloadStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 2918
Called 3 times
Total time:   0.000231
 Self time:   0.000137

count  total (s)   self (s)
    3   0.000111   0.000044   call s:ExpireStatus(a:0 ? a:1 : -1)
    3              0.000005   if a:0 > 1 ? a:2 : 1
                                let t = reltime()
                                let t:fugitive_reload_status = t
                                for tabnr in exists('*settabvar') ? range(1, tabpagenr('$')) : []
                                  call settabvar(tabnr, 'fugitive_reload_status', t)
                                endfor
                                call s:ReloadTabStatus()
                                exe s:DoAutocmdChanged(a:0 ? a:1 : -1)
    3              0.000002   else
    3   0.000053   0.000026     call s:ReloadWinStatus()
    3              0.000002   endif
    3              0.000002   return ''

FUNCTION  <SNR>190_is_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 273
Called 96 times
Total time:   0.000224
 Self time:   0.000224

count  total (s)   self (s)
   96              0.000184   return a:from_count == 0 && a:to_count > 0

FUNCTION  <SNR>94_Token()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 165
Called 2 times
Total time:   0.000057
 Self time:   0.000043

count  total (s)   self (s)
    2   0.000056   0.000041   return s:LookingAt() =~ '\k' ? expand('<cword>') : s:LookingAt()

FUNCTION  gitgutter#hunk#increment_lines_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 34
Called 80 times
Total time:   0.005341
 Self time:   0.002066

count  total (s)   self (s)
   80   0.002790   0.000796   let summary = gitgutter#hunk#summary(a:bufnr)
   80              0.000146   let summary[1] += a:count
   80   0.002339   0.001058   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  gitgutter#utility#repo_path()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 112
Called 35 times
Total time:   0.002857
 Self time:   0.001550

count  total (s)   self (s)
   35   0.001759   0.000867   let p = gitgutter#utility#getbufvar(a:bufnr, 'path', '')
   35   0.001049   0.000634   return a:shellesc ? gitgutter#utility#shellescape(p) : p

FUNCTION  <SNR>165_update_git_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 87
Called 132 times
Total time:   0.093713
 Self time:   0.010992

count  total (s)   self (s)
  132   0.002942   0.001720   call airline#util#ignore_next_focusgain()
  132   0.002907   0.001717   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
  132              0.000070   endif
  132   0.002368   0.001336   if airline#util#has_fugitive()
  132   0.081335   0.002057     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
  132              0.000596     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
  132              0.000086     endif
                              else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
  132              0.000070   endif

FUNCTION  <SNR>184_ReloadWinStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 2879
Called 3 times
Total time:   0.000027
 Self time:   0.000027

count  total (s)   self (s)
    3              0.000022   if get(b:, 'fugitive_type', '') !=# 'index' || &modified
    3              0.000002     return
                              endif
                              if !exists('b:fugitive_reltime')
                                exe s:ReloadStatusBuffer()
                                return
                              endif
                              let t = b:fugitive_reltime
                              if reltimestr(reltime(s:last_time, t)) =~# '-\|\d\{10\}\.' || reltimestr(reltime(get(s:last_times, s:cpath(s:Dir()), t), t)) =~# '-\|\d\{10\}\.'
                                exe s:ReloadStatusBuffer()
                              endif

FUNCTION  gitgutter#utility#windows()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 236
Called 8 times
Total time:   0.000145
 Self time:   0.000145

count  total (s)   self (s)
    8              0.000134   return has('win64') || has('win32') || has('win16')

FUNCTION  airline#parts#spell()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 67
Called 132 times
Total time:   0.003864
 Self time:   0.003864

count  total (s)   self (s)
  132              0.001647   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
  132              0.000278   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
  132              0.000066   endif
  132              0.000110   return ''

FUNCTION  gitgutter#hunk#summary()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 20
Called 241 times
Total time:   0.006729
 Self time:   0.003604

count  total (s)   self (s)
  241   0.006594   0.003469   return gitgutter#utility#getbufvar(a:bufnr, 'summary', [0,0,0])

FUNCTION  <SNR>190_save_last_seen_change()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 415
Called 8 times
Total time:   0.000254
 Self time:   0.000114

count  total (s)   self (s)
    8   0.000250   0.000110   call gitgutter#utility#setbufvar(a:bufnr, 'tick', getbufvar(a:bufnr, 'changedtick'))

FUNCTION  <SNR>169_ws_refresh()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 185
Called 8 times
Total time:   0.000294
 Self time:   0.000294

count  total (s)   self (s)
    8              0.000103   if get(b:, 'airline_ws_changedtick', 0) == b:changedtick
    3              0.000008     return
    5              0.000004   endif
    5              0.000083   unlet! b:airline_whitespace_check
    5              0.000026   if get(g:, 'airline_skip_empty_sections', 0)
                                exe ':AirlineRefresh!'
    5              0.000004   endif
    5              0.000027   let b:airline_ws_changedtick = b:changedtick

FUNCTION  <SNR>161_hl_group_exists()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 93
Called 502 times
Total time:   0.005309
 Self time:   0.005309

count  total (s)   self (s)
  502              0.001280   if !hlexists(a:group)
                                return 0
  502              0.002117   elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
  502              0.000229   endif
  502              0.000345   return 1

FUNCTION  airline#extensions#fugitiveline#bufname()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fugitiveline.vim line 15
Called 132 times
Total time:   0.010130
 Self time:   0.009558

count  total (s)   self (s)
  132              0.000450   if !exists('b:fugitive_name')
    3              0.000005     let b:fugitive_name = ''
    3              0.000002     try
    3              0.000017       if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
    3              0.000014       elseif exists('b:git_dir') && exists('*fugitive#repo')
    3              0.000009         if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
    3              0.000002         endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
    3              0.000001       endif
                                catch
    3              0.000002     endtry
  132              0.000068   endif
                            
  132   0.001945   0.001373   let fmod = s:ModifierFlags()
  132              0.000383   if empty(b:fugitive_name)
  132              0.003110     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  <SNR>190_is_modified()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 281
Called 80 times
Total time:   0.000285
 Self time:   0.000285

count  total (s)   self (s)
   80              0.000248   return a:from_count > 0 && a:to_count > 0 && a:from_count == a:to_count

FUNCTION  <SNR>184_ExpireStatus()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 2863
Called 3 times
Total time:   0.000067
 Self time:   0.000067

count  total (s)   self (s)
    3              0.000006   if a:bufnr == -2
    3              0.000030     let s:head_cache = {}
    3              0.000024     let s:last_time = reltime()
    3              0.000003     return ''
                              endif
                              let dir = s:Dir(a:bufnr)
                              if len(dir)
                                let s:last_times[s:cpath(dir)] = reltime()
                                if has_key(s:head_cache, dir)
                                  call remove(s:head_cache, dir)
                                endif
                              endif
                              return ''

FUNCTION  <SNR>195_syntax_stack_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 21
Called 1 time
Total time:   0.125555
 Self time:   0.125555

count  total (s)   self (s)
    1              0.125553   return map(synstack(a:lnum, a:col), 'synIDattr(v:val, "name")')

FUNCTION  <SNR>177_get_section()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/default.vim line 20
Called 33 times
Total time:   0.001769
 Self time:   0.001423

count  total (s)   self (s)
   33              0.000084   if has_key(s:section_truncate_width, a:key)
   24   0.000481   0.000248     if airline#util#winwidth(a:winnr) < s:section_truncate_width[a:key]
                                  return ''
   24              0.000011     endif
   33              0.000014   endif
   33              0.000062   let spc = g:airline_symbols.space
   33              0.000138   if !exists('g:airline_section_{a:key}')
                                return ''
   33              0.000013   endif
   33   0.000494   0.000380   let text = airline#util#getwinvar(a:winnr, 'airline_section_'.a:key, g:airline_section_{a:key})
   33              0.000216   let [prefix, suffix] = [get(a:000, 0, '%('.spc), get(a:000, 1, spc.'%)')]
   33              0.000123   return empty(text) ? '' : prefix.text.suffix

FUNCTION  airline#parts#crypt()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 59
Called 132 times
Total time:   0.001092
 Self time:   0.001092

count  total (s)   self (s)
  132              0.001006   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  jsx_pretty#comment#update_commentstring()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim line 1
Called 55 times
Total time:   5.521437
 Self time:   0.004979

count  total (s)   self (s)
   55              0.000166   let line = getline(".")
   55              0.000124   let col = col('.')
   55              0.000906   if line !~# '^\s*$' && line[: col - 1] =~# '^\s*$'    " skip indent
   41              0.000114     let col = indent('.') + 1
   55              0.000033   endif
   55   5.517185   0.000727   let syn_start = s:syn_name(line('.'), col)
   55              0.000278   let save_cursor = getcurpos()
                            
   55              0.000550   if syn_start =~? '^jsx'
                                if line =~ '^\s*//'
                                  let &l:commentstring = '// %s'
                                elseif s:syn_contains(line('.'), col, 'jsxTaggedRegion')
                                  let &l:commentstring = '<!-- %s -->'
                                elseif syn_start =~? '^jsxAttrib'
                                  let &l:commentstring = '// %s'
                                else
                                  let &l:commentstring = '{/* %s */}'
                                endif
   55              0.000031   else
   55              0.000643     let &l:commentstring = a:original
   55              0.000038   endif
                            
                              " Restore the cursor position
   55              0.000264   call setpos('.', save_cursor)

FUNCTION  airline#extensions#keymap#status()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/keymap.vim line 10
Called 132 times
Total time:   0.006239
 Self time:   0.006239

count  total (s)   self (s)
  132              0.000905   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
  132              0.000731     let short_codes = get(g:, 'airline#extensions#keymap#short_codes', {})
  132              0.000819     let label = get(g:, 'airline#extensions#keymap#label', g:airline_symbols.keymap)
  132              0.000613     let default = get(g:, 'airline#extensions#keymap#default', '')
  132              0.000240     if (label !=# '')
  132              0.000407       let label .= ' '
  132              0.000093     endif
  132              0.000273     let keymap = &keymap
  132              0.000403     if has_key(short_codes, keymap)
                                  let keymap = short_codes[keymap]
  132              0.000080     endif
  132              0.001013     return printf('%s', (!empty(keymap) && &iminsert ? (label . keymap) : (!empty(default) ? label . default : default)))
                              else
                                return ''
                              endif

FUNCTION  <SNR>195_trim()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 16
Called 2 times
Total time:   0.000048
 Self time:   0.000048

count  total (s)   self (s)
    2              0.000047   return substitute(a:line, '^\s*\|\s*$', '', 'g')

FUNCTION  <SNR>176_section_is_empty()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 182
Called 27 times
Total time:   0.000362
 Self time:   0.000362

count  total (s)   self (s)
   27              0.000034   let start=1
                            
                              " do not check for inactive windows or the tabline
   27              0.000039   if a:self._context.active == 0
                                return 0
   27              0.000066   elseif get(a:self._context, 'tabline', 0)
                                return 0
   27              0.000012   endif
                            
                              " only check, if airline#skip_empty_sections == 1
   27              0.000077   if get(g:, 'airline_skip_empty_sections', 0) == 0
   27              0.000019     return 0
                              endif
                            
                              " only check, if airline#skip_empty_sections == 1
                              if get(w:, 'airline_skip_empty_sections', -1) == 0
                                return 0
                              endif
                              " assume accents sections to be never empty
                              " (avoides, that on startup the mode message becomes empty)
                              if match(a:content, '%#__accent_[^#]*#.*__restore__#') > -1
                                return 0
                              endif
                              if empty(a:content)
                                return 1
                              endif
                              let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              if empty(list)
                                return 0 " no function in statusline text
                              endif
                              while len(list) > 0
                                let expr = list[0]
                                try
                                  " catch all exceptions, just in case
                                  if !empty(eval(expr))
                                    return 0
                                  endif
                                catch
                                  return 0
                                endtry
                                let start += 1
                                let list=matchlist(a:content, '%{\zs.\{-}\ze}', 1, start)
                              endw
                              return 1

FUNCTION  GitGutterGetHunkSummary()
    Defined: ~/.vim/plugged/vim-gitgutter/plugin/gitgutter.vim line 187
Called 129 times
Total time:   0.005679
 Self time:   0.001717

count  total (s)   self (s)
  129   0.005598   0.001636   return gitgutter#hunk#summary(winbufnr(0))

FUNCTION  airline#parts#mode()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/parts.vim line 55
Called 132 times
Total time:   0.007006
 Self time:   0.001991

count  total (s)   self (s)
  132   0.006912   0.001897   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  airline#update_statusline_focuslost()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline.vim line 146
Called 3 times
Total time:   0.000215
 Self time:   0.000215

count  total (s)   self (s)
    3              0.000138   if get(g:, 'airline_focuslost_inactive', 0)
                                let bufnr=bufnr('%')
                                call airline#highlighter#highlight_modified_inactive(bufnr)
                                call airline#highlighter#highlight(['inactive'], bufnr)
                                call airline#update_statusline_inactive(range(1, winnr('$')))
    3              0.000006   endif

FUNCTION  airline#extensions#quickfix#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/quickfix.vim line 14
Called 3 times
Total time:   0.000034
 Self time:   0.000034

count  total (s)   self (s)
    3              0.000013   if &buftype == 'quickfix'
                                let w:airline_section_a = airline#extensions#quickfix#get_type()
                                let w:airline_section_b = '%{get(w:, "quickfix_title", "")}'
                                let w:airline_section_c = ''
                                let w:airline_section_x = ''
    3              0.000002   endif

FUNCTION  gitgutter#hunk#increment_lines_removed()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 40
Called 16 times
Total time:   0.001044
 Self time:   0.000415

count  total (s)   self (s)
   16   0.000556   0.000181   let summary = gitgutter#hunk#summary(a:bufnr)
   16              0.000035   let summary[2] += a:count
   16   0.000435   0.000181   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  fugitive#Find()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 920
Called 132 times
Total time:   0.061524
 Self time:   0.040242

count  total (s)   self (s)
  132              0.000472   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
  132              0.001157   elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
  132   0.004397   0.003332   elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
  132   0.002869   0.001897   elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
  132              0.000081   endif
  132              0.000419   let dir = a:0 ? a:1 : s:Dir()
  132              0.000259   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
  132              0.000075   endif
  132   0.002296   0.001366   let rev = s:Slash(a:object)
  132   0.014470   0.001231   let tree = s:Tree(dir)
  132              0.000485   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
  132              0.000216   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
  132              0.000687   elseif rev =~# '^\.git/'
  132              0.001072     let f = substitute(rev, '^\.git', '', '')
  132   0.005413   0.001336     let cdir = fugitive#CommonDir(dir)
  132              0.000828     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
  132              0.000633     elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
  132              0.000931     elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
  132              0.000085     else
  132              0.000620       let f = simplify(dir . f)
  132              0.000083     endif
                              elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
  132              0.000072   endif
  132   0.002250   0.001252   return FugitiveVimPath(f)

FUNCTION  GetJavascriptIndent()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 352
Called 1 time
Total time:   4.541593
 Self time:   0.118227

count  total (s)   self (s)
    1   0.000028   0.000011   call s:GetVars()
    1              0.000003   let s:synid_cache = [[],[]]
    1              0.000003   let l:line = getline(v:lnum)
                              " use synstack as it validates syn state and works in an empty line
    1              0.117718   let s:stack = [''] + map(synstack(v:lnum,1),"synIDattr(v:val,'name')")
                            
                              " start with strings,comments,etc.
    1              0.000022   if s:stack[-1] =~? 'comment\|doc'
                                if l:line =~ '^\s*\*'
                                  return cindent(v:lnum)
                                elseif l:line !~ '^\s*\/[/*]'
                                  return -1
                                endif
    1              0.000011   elseif s:stack[-1] =~? b:syng_str
                                if b:js_cache[0] == v:lnum - 1 && s:Balanced(v:lnum-1,getline(v:lnum-1))
                                  let b:js_cache[0] = v:lnum
                                endif
                                return -1
    1              0.000001   endif
                            
    1              0.000014   let s:l1 = max([0,prevnonblank(v:lnum) - (s:rel ? 2000 : 1000), get(get(b:,'hi_indent',{}),'blocklnr')])
    1              0.000009   call cursor(v:lnum,1)
    1   4.312699   0.000023   if s:PreviousToken() is ''
                                return
    1              0.000000   endif
    1              0.000008   let [l:lnum, pline] = [line('.'), getline('.')[:col('.')-1]]
                            
    1              0.000016   let l:line = substitute(l:line,'^\s*','','')
    1              0.000002   let l:line_raw = l:line
    1              0.000002   if l:line[:1] == '/*'
                                let l:line = substitute(l:line,'^\%(\/\*.\{-}\*\/\s*\)*','','')
    1              0.000001   endif
    1              0.000007   if l:line =~ '^\/[/*]'
                                let l:line = ''
    1              0.000000   endif
                            
                              " the containing paren, bracket, or curly. Many hacks for performance
    1              0.000004   call cursor(v:lnum,1)
    1              0.000005   let idx = index([']',')','}'],l:line[0])
    1              0.000006   if b:js_cache[0] > l:lnum && b:js_cache[0] < v:lnum || b:js_cache[0] == l:lnum && s:Balanced(l:lnum,pline)
                                call call('cursor',b:js_cache[1:])
    1              0.000001   else
    1              0.000096     let [s:looksyn, s:top_col, s:check_in, s:l1] = [v:lnum - 1,0,0, max([s:l1, &smc ? search('\m^.\{'.&smc.',}','nbW',s:l1 + 1) + 1 : 0])]
    1              0.000002     try
    1              0.000001       if idx != -1
                                    call s:GetPair(['\[','(','{'][idx],'])}'[idx],'bW','s:SkipFunc()')
    1              0.000016       elseif getline(v:lnum) !~ '^\S' && s:stack[-1] =~? 'block\|^jsobject$'
    1   0.001218   0.000011         call s:GetPair('{','}','bW','s:SkipFunc()')
                                  else
                                    call s:AlternatePair()
    1              0.000000       endif
                                catch /^\Cout of bounds$/
                                  call cursor(v:lnum,1)
    1              0.000002     endtry
    1              0.000006     let b:js_cache[1:] = line('.') == v:lnum ? [0,0] : getpos('.')[1:2]
    1              0.000000   endif
                            
    1              0.000004   let [b:js_cache[0], num] = [v:lnum, b:js_cache[1]]
                            
    1   0.000017   0.000014   let [num_ind, is_op, b_l, l:switch_offset, s:in_jsx] = [s:Nat(indent(num)),0,0,0,0]
    1   0.109483   0.000028   if !num || s:LookingAt() == '{' && s:IsBlock()
    1              0.000003     let ilnum = line('.')
    1   0.000016   0.000012     if num && !s:in_jsx && s:LookingAt() == ')' && s:GetPair('(',')','bW',s:skip_expr)
                                  if ilnum == num
                                    let [num, num_ind] = [line('.'), indent('.')]
                                  endif
                                  if idx == -1 && s:PreviousToken() ==# 'switch' && s:IsSwitch()
                                    let l:switch_offset = &cino !~ ':' ? s:sw() : s:ParseCino(':')
                                    if pline[-1:] != '.' && l:line =~# '^\%(default\|case\)\>'
                                      return s:Nat(num_ind + l:switch_offset)
                                    elseif &cino =~ '='
                                      let l:case_offset = s:ParseCino('=')
                                    endif
                                  endif
    1              0.000000     endif
    1              0.000007     if idx == -1 && pline[-1:] !~ '[{;]'
                                  call cursor(l:lnum, len(pline))
                                  let sol = matchstr(l:line,s:opfirst)
                                  if sol is '' || sol == '/' && s:SynAt(v:lnum, 1 + len(getline(v:lnum)) - len(l:line)) =~? 'regex'
                                    if s:Continues()
                                      let is_op = s:sw()
                                    endif
                                  elseif num && sol =~# '^\%(in\%(stanceof\)\=\|\*\)$' && s:LookingAt() == '}' && s:GetPair('{','}','bW',s:skip_expr) && s:PreviousToken() == ')' && s:GetPair('(',')','bW',s:skip_expr) && (s:PreviousToken() == ']' || s:LookingAt() =~ '\k' && s:{s:PreviousToken() == '*' ? 'Previous' : ''}Token() !=# 'function')
                                    return num_ind + s:sw()
                                  else
                                    let is_op = s:sw()
                                  endif
                                  call cursor(l:lnum, len(pline))
                                  let b_l = s:Nat(s:IsContOne(is_op) - (!is_op && l:line =~ '^{')) * s:sw()
    1              0.000000     endif
                              elseif idx.s:LookingAt().&cino =~ '^-1(.*(' && (search('\m\S','nbW',num) || s:ParseCino('U'))
                                let pval = s:ParseCino('(')
                                if !pval
                                  let [Wval, vcol] = [s:ParseCino('W'), virtcol('.')]
                                  if search('\m\S','W',num)
                                    return s:ParseCino('w') ? vcol : virtcol('.')-1
                                  endif
                                  return Wval ? s:Nat(num_ind + Wval) : vcol
                                endif
                                return s:Nat(num_ind + pval + searchpair('\m(','','\m)','nbrmW',s:skip_expr,num) * s:sw())
    1              0.000000   endif
                            
                              " main return
    1              0.000006   if l:line =~ '^[])}]\|^|}'
                                if l:line_raw[0] == ')'
                                  if s:ParseCino('M')
                                    return indent(l:lnum)
                                  elseif num && &cino =~# 'm' && !s:ParseCino('m')
                                    return virtcol('.') - 1
                                  endif
                                endif
                                return num_ind
    1              0.000001   elseif num
    1   0.000024   0.000018     return s:Nat(num_ind + get(l:,'case_offset',s:sw()) + l:switch_offset + b_l + is_op)
                              endif
                              return b_l + is_op

FUNCTION  gitgutter#async#execute()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 16
Called 8 times
Total time:   0.071873
 Self time:   0.071211

count  total (s)   self (s)
    8   0.000730   0.000164   call gitgutter#debug#log('[async] '.a:cmd)
                            
    8              0.000072   let options = {   'stdoutbuffer': [],   'buffer': a:bufnr,   'handler': a:handler }
    8   0.000264   0.000169   let command = s:build_command(a:cmd)
                            
    8              0.000032   if has('nvim')
    8              0.070092     call jobstart(command, extend(options, {   'on_stdout': function('s:on_stdout_nvim'),   'on_stderr': function('s:on_stderr_nvim'),   'on_exit':   function('s:on_exit_nvim') }))
                              else
                                let job = job_start(command, {   'out_cb':   function('s:on_stdout_vim', options),   'err_cb':   function('s:on_stderr_vim', options),   'close_cb': function('s:on_exit_vim', options) })
                                let s:jobs[s:job_id(job)] = 1
    8              0.000014   endif

FUNCTION  <SNR>17_on_focus_gained()
    Defined: ~/.vim/plugged/vim-airline/plugin/airline.vim line 77
Called 3 times
Total time:   0.034005
 Self time:   0.000080

count  total (s)   self (s)
    3   0.000072   0.000033   if airline#util#try_focusgained()
    3   0.033928   0.000042     unlet! w:airline_lastmode | :call <sid>airline_refresh(1)
    3              0.000001   endif

FUNCTION  <SNR>161_exec_separator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 183
Called 168 times
Total time:   0.116858
 Self time:   0.009356

count  total (s)   self (s)
  168              0.000245   if pumvisible()
                                return
  168              0.000073   endif
  168              0.000620   let group = a:from.'_to_'.a:to.a:suffix
  168   0.033492   0.001979   let l:from = airline#themes#get_highlight(a:from.a:suffix)
  168   0.032613   0.001930   let l:to = airline#themes#get_highlight(a:to.a:suffix)
  168              0.000168   if a:inverse
   48              0.000210     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
  120              0.000060   else
  120              0.000542     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
  168              0.000083   endif
  168              0.000570   let a:dict[group] = colors
  168   0.047306   0.001999   call airline#highlighter#exec(group, colors)

FUNCTION  airline#extensions#wordcount#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/wordcount.vim line 88
Called 3 times
Total time:   0.000131
 Self time:   0.000131

count  total (s)   self (s)
    3              0.000034   let filetypes = get(g:, 'airline#extensions#wordcount#filetypes',  ['asciidoc', 'help', 'mail', 'markdown', 'nroff', 'org', 'rst', 'plaintex', 'tex', 'text'])
                              " export current filetypes settings to global namespace
    3              0.000013   let g:airline#extensions#wordcount#filetypes = filetypes
                            
                              " Check if filetype needs testing
    3              0.000006   if did_filetype()
                                " correctly test for compound filetypes (e.g. markdown.pandoc)
                                let ft = substitute(&filetype, '\.', '\\|', 'g')
                            
                                " Select test based on type of "filetypes": new=list, old=string
                                if type(filetypes) == get(v:, 't_list', type([])) ? match(filetypes, '\<'. ft. '\>') > -1 || index(filetypes, 'all') > -1 : match(&filetype, filetypes) > -1
                                  let b:airline_changedtick = -1
                                  call s:update_wordcount(1) " force update: ensures initial worcount exists
                                elseif exists('b:airline_wordcount') " cleanup when filetype is removed
                                  unlet b:airline_wordcount
                                endif
    3              0.000002   endif
                            
    3              0.000009   if exists('b:airline_wordcount')
                                call airline#extensions#prepend_to_section( 'z', '%{airline#extensions#wordcount#get()}')
    3              0.000001   endif

FUNCTION  <SNR>195_is_jsx_backticks()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 92
Called 1 time
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    1              0.000012   return a:syntax =~? 'jsxBackticks'

FUNCTION  <SNR>161_get_syn()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 38
Called 3764 times
Total time:   0.081698
 Self time:   0.081698

count  total (s)   self (s)
 3764              0.004656   let color = ''
 3764              0.008258   if hlexists(a:group)
 3764              0.020949     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, a:mode)
 3764              0.001997   endif
 3764              0.008600   if empty(color) || color == -1
                                " should always exist
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, a:mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
 3764              0.001612   endif
 3764              0.003489   return color

FUNCTION  <SNR>182_syn_name()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/comment.vim line 28
Called 55 times
Total time:   5.516458
 Self time:   5.516458

count  total (s)   self (s)
   55              5.515928   let syn_id = get(synstack(a:lnum, a:cnum), -1)
   55              0.000434   return synIDattr(syn_id, "name")

FUNCTION  <SNR>54_notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/client.vim line 181
Called 92 times
Total time:   0.008883
 Self time:   0.008134

count  total (s)   self (s)
   92   0.002083   0.001334   let channel = coc#client#get_channel(self)
   92              0.000278   if empty(channel)
                                return ''
   92              0.000057   endif
   92              0.000115   try
   92              0.000114     if s:is_vim
                                  call ch_sendraw(channel, json_encode([0, [a:method, a:args]])."\n")
   92              0.000080     else
   92              0.002435       call call('rpcnotify', [channel, a:method] + a:args)
   92              0.000096     endif
                              catch /.*/
                                if v:exception =~# 'E475'
                                  if get(g:, 'coc_vim_leaving', 0)
                                    return
                                  endif
                                  echohl Error | echom '['.self.name.'] server connection lost' | echohl None
                                  let name = self.name
                                  call s:on_exit(name, 0)
                                  execute 'silent do User ConnectionLost'.toupper(name[0]).name[1:]
                                elseif v:exception =~# 'E12'
                                  " neovim's bug, ignore it
                                else
                                  echohl Error | echo 'Error on notify ('.a:method.'): '.v:exception | echohl None
                                endif
   92              0.000117   endtry

FUNCTION  airline#extensions#nvimlsp#get_warning()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim line 38
Called 132 times
Total time:   0.002833
 Self time:   0.001825

count  total (s)   self (s)
  132   0.002769   0.001761   return airline#extensions#nvimlsp#get('Warning')

FUNCTION  gitgutter#hunk#increment_lines_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 28
Called 16 times
Total time:   0.001069
 Self time:   0.000406

count  total (s)   self (s)
   16   0.000550   0.000153   let summary = gitgutter#hunk#summary(a:bufnr)
   16              0.000031   let summary[0] += a:count
   16   0.000473   0.000208   call gitgutter#utility#setbufvar(a:bufnr, 'summary', summary)

FUNCTION  <SNR>94_Nat()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 157
Called 2 times
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    2              0.000004   return a:int * (a:int > 0)

FUNCTION  <SNR>190_process_added()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 293
Called 8 times
Total time:   0.000238
 Self time:   0.000238

count  total (s)   self (s)
    8              0.000021   let offset = 0
   24              0.000036   while offset < a:to_count
   16              0.000034     let line_number = a:to_line + offset
   16              0.000054     call add(a:modifications, [line_number, 'added'])
   16              0.000023     let offset += 1
   24              0.000018   endwhile

FUNCTION  <SNR>161_GetHiCmd()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 158
Called 67 times
Total time:   0.007039
 Self time:   0.007039

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   67              0.000085   let res = ''
   67              0.000084   let i = -1
  402              0.000353   while i < 4
  335              0.000379     let i += 1
  335              0.000874     let item = get(a:list, i, '')
  335              0.000416     if item is ''
   96              0.000060       continue
  239              0.000116     endif
  239              0.000206     if i == 0
   67              0.000187       let res .= ' guifg='.item
  172              0.000201     elseif i == 1
   34              0.000092       let res .= ' guibg='.item
  138              0.000105     elseif i == 2
   67              0.000192       let res .= ' ctermfg='.item
   71              0.000059     elseif i == 3
   34              0.000092       let res .= ' ctermbg='.item
   37              0.000030     elseif i == 4
   37              0.000202       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
  239              0.000128     endif
  306              0.000263   endwhile
   67              0.000071   return res

FUNCTION  <SNR>161_get_array()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 54
Called 941 times
Total time:   0.006071
 Self time:   0.006071

count  total (s)   self (s)
  941              0.005676   return [ a:guifg, a:guibg, a:ctermfg, a:ctermbg, empty(a:opts) ? '' : join(a:opts, ',') ]

FUNCTION  airline#extensions#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim line 71
Called 3 times
Total time:   0.000365
 Self time:   0.000207

count  total (s)   self (s)
    3              0.000016   let filetype_overrides = get(s:, 'filetype_overrides', {})
    3              0.000019   call extend(filetype_overrides, get(g:, 'airline_filetype_overrides', {}), 'force')
                            
    3   0.000208   0.000051   if s:is_excluded_window()
                                return -1
    3              0.000001   endif
                            
    3              0.000005   if &buftype == 'terminal'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
    3              0.000001   endif
                            
    3              0.000007   if &previewwindow && empty(get(w:, 'airline_section_a', ''))
                                let w:airline_section_a = 'Preview'
                                let w:airline_section_b = ''
                                let w:airline_section_c = bufname(winbufnr(winnr()))
    3              0.000001   endif
                            
    3              0.000015   if has_key(filetype_overrides, &ft) && ((&filetype == 'help' && &buftype == 'help') || &filetype !~ 'help')
                                " for help files only override it, if the buftype is also of type 'help',
                                " else it would trigger when editing Vim help files
                                let args = filetype_overrides[&ft]
                                call airline#extensions#apply_left_override(args[0], args[1])
    3              0.000001   endif
                            
    3              0.000004   if &buftype == 'help'
                                let w:airline_section_x = ''
                                let w:airline_section_y = ''
                                let w:airline_render_right = 1
    3              0.000001   endif
                            
    3              0.000009   for item in items(s:filetype_regex_overrides)
                                if match(&ft, item[0]) >= 0
                                  call airline#extensions#apply_left_override(item[1][0], item[1][1])
                                endif
    3              0.000003   endfor

FUNCTION  <SNR>51_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 313
Called 135 times
Total time:   0.000964
 Self time:   0.000964

count  total (s)   self (s)
  135              0.000359   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  135              0.000079   else
  135              0.000163     return a:path
                              endif

FUNCTION  gitgutter#utility#is_active()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 50
Called 11 times
Total time:   0.009237
 Self time:   0.001146

count  total (s)   self (s)
   11   0.009219   0.001128   return g:gitgutter_enabled && gitgutter#utility#getbufvar(a:bufnr, 'enabled', 1) && !pumvisible() && s:is_file_buffer(a:bufnr) && s:exists_file(a:bufnr) && s:not_git_dir(a:bufnr)

FUNCTION  <SNR>184_Slash()
    Defined: ~/.vim/plugged/vim-fugitive/autoload/fugitive.vim line 104
Called 396 times
Total time:   0.002968
 Self time:   0.002968

count  total (s)   self (s)
  396              0.001106   if exists('+shellslash')
                                return tr(a:path, '\', '/')
  396              0.000235   else
  396              0.000491     return a:path
                              endif

FUNCTION  coc#highlight#match_ranges()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/highlight.vim line 161
Called 1 time
Total time:   0.001428
 Self time:   0.001428

count  total (s)   self (s)
    1              0.000003   let winid = a:winid == 0 ? win_getid() : a:winid
    1              0.000003   let bufnr = a:bufnr == 0 ? winbufnr(winid) : a:bufnr
    1              0.000008   if empty(getwininfo(winid)) || (a:bufnr != 0 && winbufnr(a:winid) != a:bufnr)
                                " not valid
                                return []
    1              0.000000   endif
    1              0.000001   if !s:clear_match_by_window
    1              0.000002     let curr = win_getid()
    1              0.000003     if has('nvim')
    1              0.000908       noa call nvim_set_current_win(winid)
                                else
                                  noa call win_gotoid(winid)
    1              0.000001     endif
    1              0.000000   endif
    1              0.000002   let ids = []
    6              0.000007   for range in a:ranges
    5              0.000009     let list = []
    5              0.000011     let start = range['start']
    5              0.000009     let end = range['end']
   10              0.000027     for lnum in range(start['line'] + 1, end['line'] + 1)
    5              0.000025       let arr = getbufline(bufnr, lnum)
    5              0.000016       let line = empty(arr) ? '' : arr[0]
    5              0.000010       if empty(line)
                                    continue
    5              0.000003       endif
    5              0.000036       let colStart = lnum == start['line'] + 1 ? strlen(strcharpart(line, 0, start['character'])) + 1 : 1
    5              0.000035       let colEnd = lnum == end['line'] + 1 ? strlen(strcharpart(line, 0, end['character'])) + 1 : strlen(line) + 1
    5              0.000007       if colStart == colEnd
                                    continue
    5              0.000002       endif
    5              0.000020       call add(list, [lnum, colStart, colEnd - colStart])
   10              0.000006     endfor
    5              0.000008     if !empty(list)
    5              0.000028       let opts = s:clear_match_by_window ? {'window': a:winid} : {}
    5              0.000058       let id = matchaddpos(a:hlGroup, list, a:priority, -1, opts)
    5              0.000013       call add(ids, id)
    5              0.000003     endif
    6              0.000005   endfor
    1              0.000001   if !s:clear_match_by_window
    1              0.000002     if has('nvim')
    1              0.000007       noa call nvim_set_current_win(curr)
                                else
                                  noa call win_gotoid(curr)
    1              0.000000     endif
    1              0.000000   endif
    1              0.000001   return ids

FUNCTION  airline#util#has_lawrencium()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 158
Called 132 times
Total time:   0.001108
 Self time:   0.001108

count  total (s)   self (s)
  132              0.000448   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
  132              0.000082   endif
  132              0.000187   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 62
Called 941 times
Total time:   0.165810
 Self time:   0.078040

count  total (s)   self (s)
                              " only check for the cterm reverse attribute
                              " TODO: do we need to check all modes (gui, term, as well)?
  941              0.005375   let reverse = synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')
  941              0.003858   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
  941              0.000506   else
  941   0.030447   0.009465     let ctermfg = s:get_syn(a:group, 'fg', 'cterm')
  941   0.029371   0.008870     let ctermbg = s:get_syn(a:group, 'bg', 'cterm')
  941   0.028928   0.008726     let guifg = s:get_syn(a:group, 'fg', 'gui')
  941   0.028817   0.008804     let guibg = s:get_syn(a:group, 'bg', 'gui')
  941              0.004260     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  941              0.000913     if reverse
                                  let res = s:get_array(guibg, guifg, ctermbg, ctermfg, bold ? ['bold'] : a:000)
  941              0.000555     else
  941   0.017551   0.011479       let res = s:get_array(guifg, guibg, ctermfg, ctermbg, bold ? ['bold'] : a:000)
  941              0.000604     endif
  941              0.000451   endif
  941              0.003202   let s:hl_groups[a:group] = res
  941              0.000851   return res

FUNCTION  coc#float#nvim_refresh_scrollbar()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/float.vim line 767
Called 55 times
Total time:   0.001726
 Self time:   0.000994

count  total (s)   self (s)
   55   0.001403   0.000670   let id = coc#float#get_related(a:winid, 'scrollbar')
   55              0.000122   if id && nvim_win_is_valid(id)
                                call coc#float#nvim_scrollbar(a:winid)
   55              0.000030   endif

FUNCTION  gitgutter#sign#update_signs()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/sign.vim line 57
Called 8 times
Total time:   0.020335
 Self time:   0.016133

count  total (s)   self (s)
    8              0.000026   if exists('*sign_unplace')
                                " Vim is (hopefully) now quick enough to remove all signs then place new ones.
    8              0.000199     call sign_unplace('gitgutter', {'buffer': a:bufnr})
                            
    8   0.000230   0.000123     let modified_lines = s:handle_double_hunk(a:modified_lines)
    8   0.014809   0.010714     let signs = map(copy(modified_lines), '{'. '"buffer":   a:bufnr,'. '"group":    "gitgutter",'. '"name":     s:highlight_name_for_change(v:val[1]),'. '"lnum":     v:val[0],'. '"priority": g:gitgutter_sign_priority'. '}')
                            
    8              0.000027     if exists('*sign_placelist')
                                  call sign_placelist(signs)
                                  return
    8              0.000005     endif
                            
  600              0.000530     for sign in signs
  592              0.003906       call sign_place(0, sign.group, sign.name, sign.buffer, {'lnum': sign.lnum, 'priority': sign.priority})
  600              0.000359     endfor
    8              0.000006     return
                              endif
                            
                            
                              " Derive a delta between the current signs and the ones we want.
                              " Remove signs from lines that no longer need a sign.
                              " Upsert the remaining signs.
                            
                              call s:find_current_signs(a:bufnr)
                            
                              let new_gitgutter_signs_line_numbers = map(copy(a:modified_lines), 'v:val[0]')
                              let obsolete_signs = s:obsolete_gitgutter_signs_to_remove(a:bufnr, new_gitgutter_signs_line_numbers)
                            
                              call s:remove_signs(a:bufnr, obsolete_signs, s:remove_all_old_signs)
                              call s:upsert_new_gitgutter_signs(a:bufnr, a:modified_lines)

FUNCTION  <SNR>23_dir()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 214
Called 19 times
Total time:   0.005006
 Self time:   0.001051

count  total (s)   self (s)
   19   0.004987   0.001032   return gitgutter#utility#shellescape(fnamemodify(s:abs_path(a:bufnr, 0), ':h'))

FUNCTION  airline#highlighter#highlight_modified_inactive()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 223
Called 23 times
Total time:   0.010058
 Self time:   0.001048

count  total (s)   self (s)
   23              0.000109   if getbufvar(a:bufnr, '&modified')
   12              0.000139     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
   11              0.000009   else
   11              0.000164     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
   23              0.000014   endif
                            
   23              0.000052   if !empty(colors)
   23   0.009402   0.000392     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
   23              0.000014   endif

FUNCTION  airline#extensions#branch#get_head()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 308
Called 132 times
Total time:   0.153418
 Self time:   0.008752

count  total (s)   self (s)
  132   0.141672   0.002499   let head = airline#extensions#branch#head()
  132   0.002252   0.001662   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
  132              0.000714   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
  132   0.006602   0.001700   let head = airline#util#shorten(head, winwidth, minwidth)
  132              0.000736   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
  132              0.001181   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  airline#extensions#nvimlsp#get_error()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/nvimlsp.vim line 42
Called 132 times
Total time:   0.002790
 Self time:   0.001812

count  total (s)   self (s)
  132   0.002726   0.001748   return airline#extensions#nvimlsp#get('Error')

FUNCTION  coc#util#cursor()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/util.vim line 35
Called 19 times
Total time:   0.000249
 Self time:   0.000249

count  total (s)   self (s)
   19              0.000231   return [line('.') - 1, strchars(strpart(getline('.'), 0, col('.') - 1))]

FUNCTION  coc#rpc#notify()
    Defined: ~/.vim/plugged/coc.nvim/autoload/coc/rpc.vim line 95
Called 92 times
Total time:   0.013278
 Self time:   0.003371

count  total (s)   self (s)
   92   0.002013   0.000989   if !coc#rpc#ready()
                                return ''
   92              0.000057   endif
   92   0.010852   0.001969   call s:client['notify'](a:method, a:args)
   92              0.000109   return ''

FUNCTION  airline#extensions#hunks#get_hunks()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/hunks.vim line 95
Called 132 times
Total time:   0.049409
 Self time:   0.024874

count  total (s)   self (s)
  132              0.000438   if !get(w:, 'airline_active', 0)
                                return ''
  132              0.000072   endif
                              " Cache values, so that it isn't called too often
  132   0.005046   0.003611   if exists("b:airline_hunks") && get(b:,  'airline_changenr', 0) == b:changedtick && airline#util#winwidth() == get(s:, 'airline_winwidth', 0) && get(b:, 'source_func', '') isnot# 's:get_hunks_signify' && get(b:, 'source_func', '') isnot# 's:get_hunks_gitgutter' && get(b:, 'source_func', '') isnot# 's:get_hunks_empty' && get(b:, 'source_func', '') isnot# 's:get_hunks_changes' && get(b:, 'source_func', '') isnot# 's:get_hunks_coc'
                                return b:airline_hunks
  132              0.000074   endif
  132   0.017761   0.002108   let hunks = airline#extensions#hunks#get_raw_hunks()
  132              0.000192   let string = ''
  132   0.002137   0.001529   let winwidth = get(airline#parts#get('hunks'), 'minwidth', 100)
  132              0.000276   if !empty(hunks)
                                " hunks should contain [added, changed, deleted]
  516              0.000844     for i in [0, 1, 2]
  387   0.009238   0.004862       if (s:non_zero_only == 0 && airline#util#winwidth() > winwidth) || hunks[i] > 0
  387              0.002967         let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
  387              0.000260       endif
  516              0.000426     endfor
  132              0.000081   endif
  132   0.002799   0.002427   if index(airline#extensions#get_loaded_extensions(), 'branch') == -1 && string[-1:] == ' '
                                " branch extension not loaded, skip trailing whitespace
                                let string = string[0:-2]
  132              0.000077   endif
                            
  132              0.000310   let b:airline_hunks = string
  132              0.000293   let b:airline_changenr = b:changedtick
  132   0.003434   0.001344   let s:airline_winwidth = airline#util#winwidth()
  132              0.000158   return string

FUNCTION  293()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 8
Called 3 times
Total time:   0.000012
 Self time:   0.000012

count  total (s)   self (s)
    3              0.000010   call add(self._sections, ['|', a:0 ? a:1 : '%='])

FUNCTION  295()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 17
Called 24 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
   24              0.000091   call add(self._sections, [a:group, a:contents])

FUNCTION  airline#extensions#fzf#apply()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/fzf.vim line 28
Called 3 times
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    3              0.000005   if &filetype ==# 'fzf'
                                let spc = g:airline_symbols.space
                                call a:1.add_section('airline_a', spc.'FZF'.spc)
                                call a:1.add_section('airline_c', '')
                                return 1
    3              0.000001   endif

FUNCTION  gitgutter#utility#getbufvar()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/utility.vim line 21
Called 303 times
Total time:   0.004792
 Self time:   0.004792

count  total (s)   self (s)
  303              0.001520   let ggvars = getbufvar(a:buffer, 'gitgutter')
  303              0.002023   if type(ggvars) == type({}) && has_key(ggvars, a:varname)
  292              0.000747     return ggvars[a:varname]
   11              0.000018   endif
   11              0.000026   if a:0
   11              0.000027     return a:1
                              endif

FUNCTION  FugitiveParse()
    Defined: ~/.vim/plugged/vim-fugitive/plugin/fugitive.vim line 71
Called 3 times
Total time:   0.000061
 Self time:   0.000043

count  total (s)   self (s)
    3   0.000044   0.000026   let path = s:Slash(a:0 ? a:1 : @%)
    3              0.000011   if path !~# '^fugitive:'
    3              0.000004     return ['', '']
                              endif
                              let vals = matchlist(path, '\c^fugitive:\%(//\)\=\(.\{-\}\)\%(//\|::\)\(\x\{40,\}\|[0-3]\)\(/.*\)\=$')
                              if len(vals)
                                return [(vals[2] =~# '^.$' ? ':' : '') . vals[2] . substitute(vals[3], '^/', ':', ''), vals[1]]
                              endif
                              let v:errmsg = 'fugitive: invalid Fugitive URL ' . path
                              throw v:errmsg

FUNCTION  <SNR>52_AsyncRequest()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 112
Called 8 times
Total time:   0.004071
 Self time:   0.000927

count  total (s)   self (s)
    8              0.000288   let Cb = empty(a:args)? v:null : a:args[len(a:args) - 1]
    8              0.000117   if type(Cb) == 2
                                if !coc#rpc#ready()
                                  call Cb('service not started', v:null)
                                else
                                  call coc#rpc#request_async(a:name, a:args[0:-2], Cb)
                                endif
                                return ''
    8              0.000012   endif
    8   0.003369   0.000224   call coc#rpc#notify(a:name, a:args)
    8              0.000017   return ''

FUNCTION  <SNR>195_syntax_at()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 26
Called 1 time
Total time:   0.137548
 Self time:   0.137548

count  total (s)   self (s)
    1              0.137547   return synIDattr(synID(a:lnum, a:col, 1), 'name')

FUNCTION  <SNR>176_get_transitioned_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 140
Called 21 times
Total time:   0.015664
 Self time:   0.000815

count  total (s)   self (s)
   21              0.000026   let line = ''
   21              0.000083   if get(a:self._context, 'tabline', 0) && get(g:, 'airline#extensions#tabline#alt_sep', 0) && a:group ==# 'airline_tabsel' && a:side
                                call airline#highlighter#add_separator(a:prev_group, a:group, 0)
                                let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
                                let line .=  a:self._context.right_sep.'%#'.a:group.'#'
   21              0.000011   else
   21   0.015122   0.000273     call airline#highlighter#add_separator(a:prev_group, a:group, a:side)
   21              0.000095     let line .= '%#'.a:prev_group.'_to_'.a:group.'#'
   21              0.000079     let line .= a:side ? a:self._context.left_sep : a:self._context.right_sep
   21              0.000058     let line .= '%#'.a:group.'#'
   21              0.000011   endif
   21              0.000020   return line

FUNCTION  <SNR>195_is_jsx_element()
    Defined: ~/.vim/plugged/vim-jsx-pretty/autoload/jsx_pretty/indent.vim line 67
Called 9 times
Total time:   0.000036
 Self time:   0.000036

count  total (s)   self (s)
    9              0.000032   return a:syntax =~? 'jsxElement'

FUNCTION  <SNR>94_sw()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/indent/javascript.vim line 51
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     return shiftwidth()

FUNCTION  <SNR>52_Autocmd()
    Defined: ~/.vim/plugged/coc.nvim/plugin/coc.vim line 231
Called 83 times
Total time:   0.011456
 Self time:   0.001496

count  total (s)   self (s)
   83              0.000196   if !g:coc_workspace_initialized
                                return
   83              0.000051   endif
   83   0.010865   0.000905   call coc#rpc#notify('CocAutocmd', a:000)

FUNCTION  airline#highlighter#reset_hlcache()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/highlighter.vim line 58
Called 3 times
Total time:   0.000207
 Self time:   0.000207

count  total (s)   self (s)
    3              0.000206   let s:hl_groups = {}

FUNCTION  airline#util#prepend()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 63
Called 660 times
Total time:   0.005153
 Self time:   0.005153

count  total (s)   self (s)
  660              0.001742   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
  660              0.000330   endif
  660              0.002035   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>79_Highlight_Matching_Pair()
    Defined: /usr/local/Cellar/neovim/0.4.4/share/nvim/runtime/plugin/matchparen.vim line 39
Called 65 times
Total time:   0.562301
 Self time:   0.562301

count  total (s)   self (s)
                              " Remove any previous match.
   65              0.000258   if exists('w:paren_hl_on') && w:paren_hl_on
    7              0.000071     silent! call matchdelete(3)
    7              0.000021     let w:paren_hl_on = 0
   65              0.000040   endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   65              0.000251   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
   65              0.000032   endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   65              0.000167   let c_lnum = line('.')
   65              0.000195   let c_col = col('.')
   65              0.000091   let before = 0
                            
   65              0.000192   let text = getline(c_lnum)
   65              0.001442   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
   65              0.000131   if empty(matches)
                                let [c_before, c] = ['', '']
   65              0.000040   else
   65              0.000322     let [c_before, c] = matches[1:2]
   65              0.000039   endif
   65              0.001035   let plist = split(&matchpairs, '.\zs[:,]')
   65              0.000236   let i = index(plist, c)
   65              0.000077   if i < 0
                                " not found, in Insert mode try character before the cursor
   57              0.000243     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = strlen(c_before)
                                  let c = c_before
                                  let i = index(plist, c)
   57              0.000033     endif
   57              0.000055     if i < 0
                                  " not found, nothing to do
   57              0.000043       return
                                endif
    8              0.000006   endif
                            
                              " Figure out the arguments for searchpairpos().
    8              0.000017   if i % 2 == 0
    4              0.000007     let s_flags = 'nW'
    4              0.000012     let c2 = plist[i + 1]
    4              0.000004   else
    4              0.000012     let s_flags = 'nbW'
    4              0.000012     let c2 = c
    4              0.000024     let c = plist[i - 1]
    8              0.000007   endif
    8              0.000017   if c == '['
    4              0.000005     let c = '\['
    4              0.000005     let c2 = '\]'
    8              0.000006   endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
    8              0.000017   if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
    8              0.000006   endif
                            
    8              0.000066   if !has("syntax") || !exists("g:syntax_on")
                                let s_skip = "0"
    8              0.000007   else
                                " Build an expression that detects whether the current cursor position is
                                " in certain syntax types (string, comment, etc.), for use as
                                " searchpairpos()'s skip argument.
                                " We match "escape" for special items, such as lispEscapeSpecial.
    8              0.000075     let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                                " If executing the expression determines that the cursor is currently in
                                " one of the syntax types, then we want searchpairpos() to find the pair
                                " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                                " outside of the syntax types and s_skip should keep its value so we skip
                                " any matching pair inside the syntax types.
                                " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
    8              0.000009     try
    8              0.540363       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
                                catch /^Vim\%((\a\+)\)\=:E363/
                                  " We won't find anything, so skip searching, should keep Vim responsive.
                                  return
    8              0.000016     endtry
    8              0.000006   endif
                            
                              " Limit the search to lines visible in the window.
    8              0.000385   let stoplinebottom = line('w$')
    8              0.000193   let stoplinetop = line('w0')
    8              0.000024   if i % 2 == 0
    4              0.000011     let stopline = stoplinebottom
    4              0.000008   else
    4              0.000016     let stopline = stoplinetop
    8              0.000005   endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
    8              0.000115   if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
    8              0.000006   else
    8              0.000061     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
    8              0.000006   endif
    8              0.000009   try
    8              0.012829     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
    8              0.000013   endtry
                            
    8              0.000018   if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
    8              0.000005   endif
                            
                              " If a match is found setup match highlighting.
    8              0.000033   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
    7              0.000034     if exists('*matchaddpos')
    7              0.000320       call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
    7              0.000005     endif
    7              0.000017     let w:paren_hl_on = 1
    8              0.000006   endif

FUNCTION  airline#util#getbufvar()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/util.vim line 71
Called 6 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    6              0.000020     return getbufvar(a:bufnr, a:key, a:def)

FUNCTION  <SNR>176_get_seperator()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 155
Called 18 times
Total time:   0.020310
 Self time:   0.000467

count  total (s)   self (s)
   18   0.006721   0.000236   if airline#builder#should_change_group(a:prev_group, a:group)
   18   0.013577   0.000219     return s:get_transitioned_seperator(a:self, a:prev_group, a:group, a:side)
                              else
                                return a:side ? a:self._context.left_alt_sep : a:self._context.right_alt_sep
                              endif

FUNCTION  <SNR>179_has_fresh_changes()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter.vim line 162
Called 8 times
Total time:   0.000484
 Self time:   0.000278

count  total (s)   self (s)
    8   0.000472   0.000265   return getbufvar(a:bufnr, 'changedtick') != gitgutter#utility#getbufvar(a:bufnr, 'tick')

FUNCTION  <SNR>165_update_branch()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/branch.vim line 173
Called 132 times
Total time:   0.113258
 Self time:   0.009373

count  total (s)   self (s)
  396              0.000970   for vcs in keys(s:vcs_config)
  264   0.107863   0.003978     call {s:vcs_config[vcs].update_branch}()
  264              0.001622     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
  264              0.000168     endif
  396              0.000359   endfor

FUNCTION  gitgutter#diff#handler()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 173
Called 8 times
Total time:   0.055286
 Self time:   0.001528

count  total (s)   self (s)
    8   0.000401   0.000089   call gitgutter#debug#log(a:diff)
                            
    8              0.000020   if !bufexists(a:bufnr)
                                return
    8              0.000004   endif
                            
    8   0.006318   0.000164   call gitgutter#hunk#set_hunks(a:bufnr, gitgutter#diff#parse_diff(a:diff))
    8   0.026919   0.000216   let modified_lines = gitgutter#diff#process_hunks(a:bufnr, gitgutter#hunk#hunks(a:bufnr))
                            
    8              0.000023   let signs_count = len(modified_lines)
    8              0.000023   if g:gitgutter_max_signs != -1 && signs_count > g:gitgutter_max_signs
                                call gitgutter#utility#warn_once(a:bufnr, printf( 'exceeded maximum number of signs (%d > %d, configured by g:gitgutter_max_signs).', signs_count, g:gitgutter_max_signs), 'max_signs')
                                call gitgutter#sign#clear_signs(a:bufnr)
                            
    8              0.000004   else
    8              0.000023     if g:gitgutter_signs || g:gitgutter_highlight_lines || g:gitgutter_highlight_linenrs
    8   0.020983   0.000648       call gitgutter#sign#update_signs(a:bufnr, modified_lines)
    8              0.000005     endif
    8              0.000005   endif
                            
    8   0.000364   0.000110   call s:save_last_seen_change(a:bufnr)
    8              0.000046   if exists('#User#GitGutter')
                                let g:gitgutter_hook_context = {'bufnr': a:bufnr}
                                execute 'doautocmd' s:nomodeline 'User GitGutter'
                                unlet g:gitgutter_hook_context
    8              0.000004   endif

FUNCTION  tmux_focus_events#focus_gained()
    Defined: ~/.vim/plugged/vim-tmux-focus-events/autoload/tmux_focus_events.vim line 27
Called 3 times
Total time:   0.002845
 Self time:   0.002775

count  total (s)   self (s)
    3              0.000041   if !&autoread
                                return
    3              0.000003   endif
    3   0.000141   0.000071   if <SID>cursor_in_cmd_line()
    1              0.000005     augroup focus_gained_checktime
    1              0.002388       au!
                                  " perform checktime ASAP when outside cmd line
    1              0.000186       au * * call <SID>delayed_checktime()
    1              0.000001     augroup END
    2              0.000003   else
    2              0.000008     silent checktime
    3              0.000003   endif

FUNCTION  <SNR>169_check_mixed_indent_file()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions/whitespace.vim line 34
Called 5 times
Total time:   0.000655
 Self time:   0.000655

count  total (s)   self (s)
    5              0.000052   let c_like_langs = get(g:, 'airline#extensions#c_like_langs', [ 'arduino', 'c', 'cpp', 'cuda', 'go', 'javascript', 'ld', 'php' ])
    5              0.000025   if index(c_like_langs, &ft) > -1
                                " for C-like languages: allow /** */ comment style with one space before the '*'
    5              0.000010     let head_spc = '\v(^ +\*@!)'
                              else
                                let head_spc = '\v(^ +)'
    5              0.000003   endif
    5              0.000248   let indent_tabs = search('\v(^\t+)', 'nw')
    5              0.000250   let indent_spc  = search(head_spc, 'nw')
    5              0.000012   if indent_tabs > 0 && indent_spc > 0
                                return printf("%d:%d", indent_tabs, indent_spc)
    5              0.000004   else
    5              0.000005     return ''
                              endif

FUNCTION  <SNR>190_process_hunk()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/diff.vim line 240
Called 96 times
Total time:   0.024928
 Self time:   0.010413

count  total (s)   self (s)
   96              0.000171   let modifications = []
   96              0.000206   let from_line  = a:hunk[0]
   96              0.000190   let from_count = a:hunk[1]
   96              0.000176   let to_line    = a:hunk[2]
   96              0.000179   let to_count   = a:hunk[3]
                            
   96   0.001061   0.000837   if s:is_added(from_count, to_count)
    8   0.000353   0.000115     call s:process_added(modifications, from_count, to_count, to_line)
    8   0.000615   0.000114     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count)
                            
   88   0.001065   0.000847   elseif s:is_removed(from_count, to_count)
    8   0.000184   0.000105     call s:process_removed(modifications, from_count, to_count, to_line)
    8   0.000675   0.000122     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count)
                            
   80   0.001123   0.000839   elseif s:is_modified(from_count, to_count)
   64   0.003047   0.000873     call s:process_modified(modifications, from_count, to_count, to_line)
   64   0.005174   0.000884     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
                            
   16   0.000262   0.000204   elseif s:is_modified_and_added(from_count, to_count)
    8   0.003497   0.000114     call s:process_modified_and_added(modifications, from_count, to_count, to_line)
    8   0.000702   0.000135     call gitgutter#hunk#increment_lines_added(a:bufnr, to_count - from_count)
    8   0.000626   0.000108     call gitgutter#hunk#increment_lines_modified(a:bufnr, from_count)
                            
    8   0.000148   0.000105   elseif s:is_modified_and_removed(from_count, to_count)
    8   0.000537   0.000177     call s:process_modified_and_removed(modifications, from_count, to_count, to_line)
    8   0.000641   0.000108     call gitgutter#hunk#increment_lines_modified(a:bufnr, to_count)
    8   0.000616   0.000126     call gitgutter#hunk#increment_lines_removed(a:bufnr, from_count - to_count)
                            
   96              0.000049   endif
   96              0.000114   return modifications

FUNCTION  gitgutter#hunk#set_hunks()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/hunk.vim line 5
Called 8 times
Total time:   0.000651
 Self time:   0.000184

count  total (s)   self (s)
    8   0.000329   0.000096   call gitgutter#utility#setbufvar(a:bufnr, 'hunks', a:hunks)
    8   0.000316   0.000082   call s:reset_summary(a:bufnr)

FUNCTION  airline#extensions#get_loaded_extensions()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/extensions.vim line 499
Called 132 times
Total time:   0.000372
 Self time:   0.000372

count  total (s)   self (s)
  132              0.000284   return s:loaded_ext

FUNCTION  airline#builder#new()
    Defined: ~/.vim/plugged/vim-airline/autoload/airline/builder.vim line 229
Called 3 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
    3              0.000030   let builder = copy(s:prototype)
    3              0.000008   let builder._context = a:context
    3              0.000005   let builder._sections = []
                            
    3              0.000043   call extend(builder._context, { 'left_sep': g:airline_left_sep, 'left_alt_sep': g:airline_left_alt_sep, 'right_sep': g:airline_right_sep, 'right_alt_sep': g:airline_right_alt_sep, }, 'keep')
    3              0.000003   return builder

FUNCTION  <SNR>188_on_stdout_nvim()
    Defined: ~/.vim/plugged/vim-gitgutter/autoload/gitgutter/async.vim line 56
Called 16 times
Total time:   0.000464
 Self time:   0.000464

count  total (s)   self (s)
   16              0.000128   if empty(self.stdoutbuffer)
    8              0.000047     let self.stdoutbuffer = a:data
    8              0.000005   else
    8              0.000180     let self.stdoutbuffer = self.stdoutbuffer[:-2] + [self.stdoutbuffer[-1] . a:data[0]] + a:data[1:]
   16              0.000012   endif

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
   40  83.229174   0.224602  <SNR>94_PreviousToken()
   55   5.521437   0.004979  jsx_pretty#comment#update_commentstring()
   55   5.516458             <SNR>182_syn_name()
    1   4.815756   0.000570  GetJsxIndent()
    1   4.805732   0.000224  jsx_pretty#indent#get()
    1   4.541593   0.118227  GetJavascriptIndent()
   41   4.418236             <SNR>94_SynAt()
    6   2.588294   0.000600  <SNR>58_update_from_tmux()
   12   2.587694   0.001388  <SNR>58_TmuxBufferName()
   65   0.562301             <SNR>79_Highlight_Matching_Pair()
  132   0.301672   0.021101  airline#check_mode()
   23   0.267966   0.044994  airline#highlighter#highlight()
  569   0.171107   0.041463  airline#highlighter#exec()
  941   0.165810   0.078040  airline#highlighter#get_highlight()
  132   0.153418   0.008752  airline#extensions#branch#get_head()
  132   0.139173   0.005773  airline#extensions#branch#head()
    1   0.137602   0.000020  <SNR>195_start_syntax()
    1   0.137548             <SNR>195_syntax_at()
    1   0.126235   0.000527  <SNR>195_syntax_context()
    1   0.125555             <SNR>195_syntax_stack_at()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   55              5.516458  <SNR>182_syn_name()
   41              4.418236  <SNR>94_SynAt()
   65              0.562301  <SNR>79_Highlight_Matching_Pair()
   40  83.229174   0.224602  <SNR>94_PreviousToken()
    1              0.137548  <SNR>195_syntax_at()
    1              0.125555  <SNR>195_syntax_stack_at()
    1   4.541593   0.118227  GetJavascriptIndent()
 3764              0.081698  <SNR>161_get_syn()
  941   0.165810   0.078040  airline#highlighter#get_highlight()
    8   0.071873   0.071211  gitgutter#async#execute()
   23   0.267966   0.044994  airline#highlighter#highlight()
  569   0.171107   0.041463  airline#highlighter#exec()
  132   0.061524   0.040242  fugitive#Find()
   55              0.034177  <SNR>151_parse_screen()
  132   0.054159   0.026933  airline#extensions#whitespace#check()
  132   0.049409   0.024874  airline#extensions#hunks#get_hunks()
  132   0.301672   0.021101  airline#check_mode()
    5              0.018914  <SNR>169_check_mixed_indent()
 1589              0.018330  airline#util#winwidth()
  132   0.019917   0.017692  <SNR>165_update_untracked()

